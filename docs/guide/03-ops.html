
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>3. 호스트 시스템 관리 및 운영 &#8212; VirtOn Documents 1.0 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=e884a2db" />
  
  <!-- So that users can add custom icons -->
  <script src="../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../_static/documentation_options.js?v=a681ed88"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'guide/03-ops';</script>
    <link rel="icon" href="../_static/favicon.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="4. GUI" href="04-gui.html" />
    <link rel="prev" title="2. Proxmox VE 기본설치" href="02-install.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.png" class="logo__image only-light" alt="VirtOn Documents 1.0 documentation - Home"/>
    <img src="../_static/logo.png" class="logo__image only-dark pst-js-only" alt="VirtOn Documents 1.0 documentation - Home"/>
  
  
</a></div>
        <div class="sidebar-primary-item">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">기본 매뉴얼</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="01-intro.html">1. 개요</a></li>
<li class="toctree-l1"><a class="reference internal" href="02-install.html">2. Proxmox VE 기본설치</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">3. 운영</a></li>
<li class="toctree-l1"><a class="reference internal" href="04-gui.html">4. GUI</a></li>
<li class="toctree-l1"><a class="reference internal" href="05-cluster.html">5. Cluster</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/guide/03-ops.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button>


<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>3. 호스트 시스템 관리 및 운영</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">3.1. 패키지 레포지토리</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#proxmox-ve">3.1.1. Proxmox VE의 레포지토리</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#proxmox-ve-enterprise-repository">3.1.2. Proxmox VE Enterprise Repository</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#proxmox-ve-no-subscription-repository">3.1.3. Proxmox VE No-Subscription Repository</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#proxmox-ve-test-repository">3.1.4. Proxmox VE Test Repository</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ceph-squid-enterprise-repository">3.1.5. Ceph Squid Enterprise Repository</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ceph-squid-no-subscription-repository">3.1.6. Ceph Squid No-Subscription Repository</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ceph-squid-test-repository">3.1.7. Ceph Squid Test Repository</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ceph-reef-enterprise-repository">3.1.8. Ceph Reef Enterprise Repository</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ceph-reef-no-subscription-repository">3.1.9. Ceph Reef No-Subscription Repository</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ceph-reef-test-repository">3.1.10. Ceph Reef Test Repository</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">3.2. 시스템 소프트웨어 업데이트</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">3.3. 펌웨어 업데이트</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">3.3.1. 영구 펌웨어</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">3.4. 네트워크 구성</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">3.4.1. 네트워크 변경 사항 적용</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">3.4.2. 명명 규칙</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">3.4.3. 네트워크 구성 선택하기</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">3.4.4. 브릿지를 사용한 기본 구성</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">3.4.5 라우팅 구성</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#linux-bond">3.4.7 Linux Bond</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#vlan-802-1q">3.4.8. VLAN 802.1Q</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ipv6">3.4.9. 노드에서 IPv6 비활성화하기</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mac">3.4.10. 브릿지에서 MAC 학습 기능 비활성화하기</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">3.5. 시간 동기화</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ntp">3.5.1. 사용자 지정 NTP 서버 사용</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id13">3.6. 외부 메트릭 서버</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#graphite">3.6.1. Graphite 서버 구성</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#influxdb">3.6.2. InfluxDB 플러그인 구성</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id14">3.7. 디스크 상태 모니터링</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#logical-volume-manager-lvm">3.8. Logical Volume Manager (LVM)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">3.8.1. 하드웨어</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id16">3.8.2. 부트 로더</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id17">3.8.3. 볼륨 그룹 생성</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#var-lib-vz-lv">3.8.4. <em>var/lib/vz</em>에 대한 추가 LV 만들기</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#thin-pool">3.8.5. thin pool 크기 조정하기</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lvm-thin-pool">3.8.6. LVM-thin pool 생성</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#zfs">3.9. ZFS</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id18">3.9.1. 하드웨어</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#root">3.9.2. Root 파일시스템으로 설치</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#zfs-raid">3.9.3. ZFS RAID 레벨 고려 사항</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="id1">
<h1>3. 호스트 시스템 관리 및 운영<a class="headerlink" href="#id1" title="Link to this heading"><span>#</span></a></h1>
<p>Proxmox VE는 Debian GNU/Linux를 기반으로 하며, 추가 레포지토리를 통해 Proxmox VE 관련 패키지를 제공합니다. 즉, 보안 업데이트 및 버그 수정을 포함한 모든 범위의 Debian 패키지를 사용할 수 있습니다. Proxmox VE는 우분투 커널을 기반으로 하는 자체 Linux 커널을 제공합니다. 필요한 모든 가상화 및 컨테이너 기능이 활성화되어 있으며 ZFS 및 몇 가지 추가 하드웨어 드라이버가 포함되어 있습니다.<br><br></p>
<section id="id2">
<h2>3.1. 패키지 레포지토리<a class="headerlink" href="#id2" title="Link to this heading"><span>#</span></a></h2>
<p>Proxmox VE는 다른 Debian 기반 시스템과 마찬가지로 <point>APT</point>를 패키지 관리 도구로 사용합니다.<br>
Proxmox VE는 매일 패키지 업데이트를 자동으로 확인합니다. <point>root&#64;pam</point> 사용자는 사용 가능한 업데이트에 대해 이메일을 통해 알림을 받습니다. GUI에서 <point>changelog</point>버튼을 사용하여 선택한 업데이트에 대한 자세한 내용을 볼 수 있습니다.<br><br></p>
<section id="proxmox-ve">
<h3>3.1.1. Proxmox VE의 레포지토리<a class="headerlink" href="#proxmox-ve" title="Link to this heading"><span>#</span></a></h3>
<p>레포지토리는 소프트웨어 패키지의 모음으로, 새 소프트웨어를 설치하는 데 사용할 수 있을 뿐만 아니라 새 업데이트를 받는 데도 중요합니다.<br></p>
<blockquote>
<div><p><img alt="" src="../_images/pin.png" /> <b>NOTE</b><br>
최신 보안 업데이트, 버그 수정 및 새로운 기능을 받으려면 유효한 Debian 및 Proxmox 레포지토리가 필요합니다.</p>
</div></blockquote>
<br>
<p>APT 레포지토리는 <code class="docutils literal notranslate"><span class="pre">/etc/apt/sources.list</span></code> 파일과 <code class="docutils literal notranslate"><span class="pre">/etc/apt/sources.list.d/</span></code>에 있는 <point>.list</point> 확장자 파일에 정의되어 있습니다.<br></p>
<p><img alt="" src="../_images/admin_1.png" /><br></p>
<p>Proxmox VE 7부터는 웹 인터페이스에서 레포지토리 상태를 확인할 수 있습니다. 노드 요약 패널에는 개략적인 상태 개요가 표시되며, 별도의 <point>Repository</point> 패널에는 구성된 모든 레포지토리의 심층적인 상태와 목록이 표시됩니다.</p>
<p>레포지토리 활성화 또는 비활성화와 같은 기본적인 레포지토리 관리도 지원됩니다.<br></p>
<p><point>sources.list 파일</point><br></p>
<p><point>sources.list</point> 파일에서 각 줄은 패키지 레포지토리를 정의합니다.</p>
<p>선호하는 소스가 가장 먼저 나와야 하며, 빈 줄은 무시됩니다. <point>#</point> 문자는 해당 줄의 나머지 부분을 주석으로 표시합니다. 레포지토리에서 사용 가능한 패키지는 <point>apt-get update</point> 명령을 실행하여 얻습니다. 업데이트는 <point>apt-get</point>을 사용하여 직접 설치하거나, GUI(Node → Updates)를 통해 설치할 수 있습니다.<br></p>
<p><point>/etc/apt/sources.list 파일</point><br></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">deb</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">deb</span><span class="o">.</span><span class="n">debian</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">debian</span> <span class="n">bookworm</span> <span class="n">main</span> <span class="n">contrib</span>
<span class="n">deb</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">deb</span><span class="o">.</span><span class="n">debian</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">debian</span> <span class="n">bookworm</span><span class="o">-</span><span class="n">updates</span> <span class="n">main</span> <span class="n">contrib</span>

<span class="c1"># security updates</span>
<span class="n">deb</span> 
<span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">security</span><span class="o">.</span><span class="n">debian</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">debian</span><span class="o">-</span><span class="n">security</span> <span class="n">bookworm</span><span class="o">-</span><span class="n">security</span> <span class="n">main</span> <span class="n">contrib</span>

</pre></div>
</div>
<p>Proxmox VE는 세 가지 패키지 레포지토리를 제공합니다.<br><br></p>
</section>
<section id="proxmox-ve-enterprise-repository">
<h3>3.1.2. Proxmox VE Enterprise Repository<a class="headerlink" href="#proxmox-ve-enterprise-repository" title="Link to this heading"><span>#</span></a></h3>
<p>이는 권장되는 저장소이며 모든 버트온 라이선스 구독자가 이용할 수 있습니다. 가장 안정적인 패키지가 포함되어 있으며 프로덕션 환경에 적합합니다. <point>pve-enterprise</point> 저장소는 기본적으로 활성화되어 있습니다:<br>
pve-enterprise 저장소에 접근하려면 유효한 구독 키가 필요하다는 점에 유의하십시오. 당사는 다양한 지원 수준을 제공하며, 자세한 내용은 https://proxmox.com/en/proxmox-virtual-environment/pricing에서 확인하실 수 있습니다.
파일에서 줄 시작 부분에 ‘#’을 추가하여 주석 처리함으로써 이 저장소를 비활성화할 수 있습니다. 이렇게 하면 호스트에 구독 키가 없는 경우 오류 메시지가 표시되지 않습니다. 이 경우 pve-no-subscription 저장소를 구성하시기 바랍니다.<br>이 레포지토리는 권장 레포지토리이며 모든 Proxmox VE 구독 사용자가 사용할 수 있습니다. 가장 안정적인 패키지가 포함되어 있으며 프로덕션용으로 적합합니다. <point>pve-enterprise</point> 레포지토리는 기본적으로 활성화되어 있습니다:<br><br></p>
<p><point>/etc/apt/sources.list.d/pve-enterprise.list 파일</point><br></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">deb</span> 
<span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">enterprise</span><span class="o">.</span><span class="n">proxmox</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">debian</span><span class="o">/</span><span class="n">pve</span> <span class="n">bookworm</span> <span class="n">pve</span><span class="o">-</span><span class="n">enterprise</span>
</pre></div>
</div>
<p><point>pve-enterprise</point> 레포지토리에 액세스하려면 유효한 구독 키가 필요하다는 점에 유의하세요.</p>
<blockquote>
<div><p><img alt="" src="../_images/pin.png" /> 참고<br>
위 줄의 첫 번째 줄에 <point>#</point>를 사용하여 주석을 달면 이 레포지토리를 비활성화할 수 있습니다. 이렇게 하면 호스트에 구독 키가 없는 경우 오류 메시지가 표시되지 않습니다. 이 경우 <point>pve-no-subscription</point> 레포지토리를 구성하세요.</p>
</div></blockquote>
<br>
</section>
<section id="proxmox-ve-no-subscription-repository">
<h3>3.1.3. Proxmox VE No-Subscription Repository<a class="headerlink" href="#proxmox-ve-no-subscription-repository" title="Link to this heading"><span>#</span></a></h3>
<p>이름에서 알 수 있듯이 이 레포지토리에 액세스하는 데는 구독 키가 필요하지 않습니다. 테스트 및 비프로덕션 용도로 사용할 수 있습니다. 이러한 패키지는 항상 철저한 테스트와 검증을 거치는 것은 아니므로 프로덕션 서버에서는 사용하지 않는 것이 좋습니다.<br></p>
<p>이 레포지토리는 <point>/etc/apt/sources.list</point>에서 구성하는 것이 좋습니다.<br><br></p>
<p><point><img alt="" src="../_images/pin.png" /> /etc/apt/sources.list 파일</point><br></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">deb</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">ftp</span><span class="o">.</span><span class="n">debian</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">debian</span> <span class="n">bookworm</span> <span class="n">main</span> <span class="n">contrib</span>
<span class="n">deb</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">ftp</span><span class="o">.</span><span class="n">debian</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">debian</span> <span class="n">bookworm</span><span class="o">-</span><span class="n">updates</span> <span class="n">main</span> <span class="n">contrib</span>

<span class="c1"># Proxmox VE pve-no-subscription repository provided by proxmox.com,</span>
<span class="c1"># NOT recommended for production use</span>
<span class="n">deb</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">download</span><span class="o">.</span><span class="n">proxmox</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">debian</span><span class="o">/</span><span class="n">pve</span> <span class="n">bookworm</span> <span class="n">pve</span><span class="o">-</span><span class="n">no</span><span class="o">-</span><span class="n">subscription</span>

<span class="c1"># security updates</span>
<span class="n">deb</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">security</span><span class="o">.</span><span class="n">debian</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">debian</span><span class="o">-</span><span class="n">security</span> <span class="n">bookworm</span><span class="o">-</span><span class="n">security</span> <span class="n">main</span> <span class="n">contrib</span>
</pre></div>
</div>
<p><br><br></p>
</section>
<section id="proxmox-ve-test-repository">
<h3>3.1.4. Proxmox VE Test Repository<a class="headerlink" href="#proxmox-ve-test-repository" title="Link to this heading"><span>#</span></a></h3>
<p>이 레지토리에는 최신 패키지가 포함되어 있으며 주로 개발자가 새로운 기능을 테스트하는 데 사용됩니다. 구성하려면 <point>/etc/apt/sources.list</point>에 다음 줄을 추가합니다:<br>
<point><img alt="" src="../_images/pin.png" /> pvetest에 대한 sources.list 항목</point><br></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">deb</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">download</span><span class="o">.</span><span class="n">proxmox</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">debian</span><span class="o">/</span><span class="n">pve</span> <span class="n">bookworm</span> <span class="n">pvetest</span>
</pre></div>
</div>
<blockquote>
<div><p><img alt="" src="../_images/pin.png" /> 경고<br>
<point>pvetest</point> 레포지토리는 이름에서 알 수 있듯이 새로운 기능이나 버그 수정을 테스트하는 용도로만 사용해야 합니다.</p>
</div></blockquote>
</section>
<section id="ceph-squid-enterprise-repository">
<h3>3.1.5. Ceph Squid Enterprise Repository<a class="headerlink" href="#ceph-squid-enterprise-repository" title="Link to this heading"><span>#</span></a></h3>
<p>이 레지토리에는 엔터프라이즈용 Proxmox VE Ceph 19.2 Squid 패키지가 있습니다. 프로덕션에 적합합니다. Proxmox VE에서 Ceph 클라이언트 또는 전체 Ceph 클러스터를 실행하는 경우 이 레포지토리를 사용하세요.<br></p>
<p><point><img alt="" src="../_images/pin.png" /> /etc/apt/sources.list.d/ceph.list 파일</point><br></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">deb</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">enterprise</span><span class="o">.</span><span class="n">proxmox</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">debian</span><span class="o">/</span><span class="n">ceph</span><span class="o">-</span><span class="n">squid</span> <span class="n">bookworm</span> <span class="n">enterprise</span>
</pre></div>
</div>
<p><br><br></p>
</section>
<section id="ceph-squid-no-subscription-repository">
<h3>3.1.6. Ceph Squid No-Subscription Repository<a class="headerlink" href="#ceph-squid-no-subscription-repository" title="Link to this heading"><span>#</span></a></h3>
<p>이 Ceph 레포지토리에는 엔터프라이즈 레포지토리로 이동하기 전과 테스트 레포지토리로 이동한 후의 Ceph 19.2 Squid 패키지가 포함되어 있습니다.</p>
<blockquote>
<div><p><img alt="" src="../_images/pin.png" /> 참고<br>
프로덕션 머신에는 엔터프라이즈 레포지토리를 사용하는 것이 좋습니다.
<br></p>
</div></blockquote>
<p><point><img alt="" src="../_images/pin.png" /> /etc/apt/sources.list.d/ceph.list 파일</point><br></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">deb</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">download</span><span class="o">.</span><span class="n">proxmox</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">debian</span><span class="o">/</span><span class="n">ceph</span><span class="o">-</span><span class="n">squid</span> <span class="n">bookworm</span> <span class="n">no</span><span class="o">-</span><span class="n">subscription</span>
</pre></div>
</div>
<p><br><br></p>
</section>
<section id="ceph-squid-test-repository">
<h3>3.1.7. Ceph Squid Test Repository<a class="headerlink" href="#ceph-squid-test-repository" title="Link to this heading"><span>#</span></a></h3>
<p>이 Ceph 레포지토리에는 메인 레포지토리로 이동하기 전의 Ceph 19.2 Squid 패키지가 포함되어 있습니다. 이 레포지토리는 Proxmox VE에서 새로운 Ceph 릴리스를 테스트하는 데 사용됩니다.<br></p>
<p><point><img alt="" src="../_images/pin.png" /> /etc/apt/sources.list.d/ceph.list 파일</point><br></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">deb</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">download</span><span class="o">.</span><span class="n">proxmox</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">debian</span><span class="o">/</span><span class="n">ceph</span><span class="o">-</span><span class="n">squid</span> <span class="n">bookworm</span> <span class="n">test</span>
</pre></div>
</div>
<p><br><br></p>
</section>
<section id="ceph-reef-enterprise-repository">
<h3>3.1.8. Ceph Reef Enterprise Repository<a class="headerlink" href="#ceph-reef-enterprise-repository" title="Link to this heading"><span>#</span></a></h3>
<p>이 레포지토리에는 엔터프라이즈용 Proxmox VE Ceph 18.2 Reef 패키지가 있습니다. 프로덕션에 적합합니다. 이 레포지토리는 Proxmox VE에서 Ceph 클라이언트 또는 전체 Ceph 클러스터를 실행하는 경우 사용합니다.<br></p>
<p><point><img alt="" src="../_images/pin.png" /> /etc/apt/sources.list.d/ceph.list 파일</point><br></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">deb</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">enterprise</span><span class="o">.</span><span class="n">proxmox</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">debian</span><span class="o">/</span><span class="n">ceph</span><span class="o">-</span><span class="n">reef</span> <span class="n">bookworm</span> <span class="n">enterprise</span>
</pre></div>
</div>
<p><br><br></p>
</section>
<section id="ceph-reef-no-subscription-repository">
<h3>3.1.9. Ceph Reef No-Subscription Repository<a class="headerlink" href="#ceph-reef-no-subscription-repository" title="Link to this heading"><span>#</span></a></h3>
<p>이 Ceph 레포지토리에는 엔터프라이즈 레포지토리로 이동하기 전과 테스트 레포지토리로 이동한 후의 Ceph 18.2 Reef 패키지가 포함되어 있습니다.<br></p>
<blockquote>
<div><p><img alt="" src="../_images/pin.png" /> 참고<br>
프로덕션 머신에는 엔터프라이즈 레포지토리를 사용하는 것이 좋습니다.
<br></p>
</div></blockquote>
<p><point><img alt="" src="../_images/pin.png" /> /etc/apt/sources.list.d/ceph.list 파일</point><br></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">deb</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">download</span><span class="o">.</span><span class="n">proxmox</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">debian</span><span class="o">/</span><span class="n">ceph</span><span class="o">-</span><span class="n">reef</span> <span class="n">bookworm</span> <span class="n">no</span><span class="o">-</span><span class="n">subscription</span>
</pre></div>
</div>
<p><br><br></p>
</section>
<section id="ceph-reef-test-repository">
<h3>3.1.10. Ceph Reef Test Repository<a class="headerlink" href="#ceph-reef-test-repository" title="Link to this heading"><span>#</span></a></h3>
<p>이 Ceph 레포지토리에는 메인 레포지토리로 이동하기 전의 Ceph 18.2 Reef 패키지가 포함되어 있습니다. 이 레포지토리는 Proxmox VE에서 새로운 Ceph 릴리스를 테스트하는 데 사용됩니다.<br></p>
<p><point><img alt="" src="../_images/pin.png" /> /etc/apt/sources.list.d/ceph.list 파일</point><br></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">deb</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">download</span><span class="o">.</span><span class="n">proxmox</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">debian</span><span class="o">/</span><span class="n">ceph</span><span class="o">-</span><span class="n">reef</span> <span class="n">bookworm</span> <span class="n">test</span>
</pre></div>
</div>
<p><br><br></p>
</section>
</section>
<section id="id3">
<h2>3.2. 시스템 소프트웨어 업데이트<a class="headerlink" href="#id3" title="Link to this heading"><span>#</span></a></h2>
<p>Proxmox는 모든 레포지토리에 대해 정기적으로 업데이트를 제공합니다. 업데이트를 설치하려면 웹 기반 GUI 또는 다음 CLI 명령을 사용하세요:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># apt-get update</span>
<span class="c1"># apt-get dist-upgrade</span>
</pre></div>
</div>
<blockquote>
<div><p><img alt="" src="../_images/pin.png" /> 참고<br>
APT 패키지 관리 시스템은 매우 유연하며 많은 기능을 제공합니다.<br>
최신 패치 및 보안 관련 수정 사항을 적용하려면 정기적인 업데이트가 필수입니다. 주요 시스템 업그레이드는 Proxmox VE 커뮤니티 포럼에서 발표됩니다.</p>
</div></blockquote>
<p><br><br></p>
</section>
<section id="id4">
<h2>3.3. 펌웨어 업데이트<a class="headerlink" href="#id4" title="Link to this heading"><span>#</span></a></h2>
<p>펌웨어 업데이트는 베어메탈 서버에서 Proxmox VE를 실행할 때 적용해야 합니다. 디바이스 패스스루를 사용하는 경우와 같이 게스트 내에서 펌웨어 업데이트를 구성하는 것이 적절한지 여부는 설정에 따라 크게 달라지므로 본 문서의 범위를 벗어납니다.<br></p>
<p>펌웨어 업데이트는 정기적인 소프트웨어 업데이트와 더불어 안정적이고 안전한 운영을 위해서도 중요합니다.
펌웨어 업데이트를 받아 적용할 때는 가능한 한 빨리 또는 전혀 받지 않도록 사용 가능한 옵션을 조합하여 적용하는 것이 좋습니다.<br></p>
<p>펌웨어라는 용어는 일반적으로 언어학적으로 마이크로코드(CPU용)와 펌웨어(기타 장치용)로 나뉩니다.<br><br></p>
<section id="id5">
<h3>3.3.1. 영구 펌웨어<a class="headerlink" href="#id5" title="Link to this heading"><span>#</span></a></h3>
<p>이 섹션은 모든 장치에 적합합니다. 일반적으로 BIOS/UEFI 업데이트에 포함된 업데이트된 마이크로코드는 마더보드에 저장되는 반면, 다른 펌웨어는 각 장치에 저장됩니다. 이 영구적인 방법은 부팅 시 업데이트된 마이크로코드를 최대한 빨리 정기적으로 로드할 수 있기 때문에 CPU에 특히 중요합니다.
이는 모든 디바이스에 적용됩니다. 일반적으로 BIOS/UEFI 업데이트에 포함되는 업데이트된 마이크로코드는 마더보드에 저장되며, 다른 펌웨어는 해당 디바이스에 저장됩니다. 이 영구적인 방식은 특히 CPU에 중요한데, 부팅 시 가능한 한 빨리 업데이트된 마이크로코드를 정기적으로 로드할 수 있기 때문입니다.
<br>
사용 가능한 업데이트 방법은 하드웨어 벤더에 문의하여 확인하시기 바랍니다.<br>
서버의 경우 편리한 업데이트 방법으로는 다음과 같은 옵션이 있습니다:</p>
<ul class="simple">
<li><p>Dell의 Lifecycle Manager</p></li>
<li><p>HPE의 Service Pack
일부 하드웨어의 경우 Linux용 유틸리티도 제공됩니다:</p></li>
<li><p>NVIDIA ConnectX 카드: mlxup</p></li>
<li><p>Broadcom 네트워크 카드: bnxtnvm 또는 niccli
LVFS(Linux Vendor Firmware Service)도 하나의 옵션입니다. 단, 다음 조건을 충족해야 합니다:</p></li>
<li><p>하드웨어 벤더와의 협력 관계가 있어야 함</p></li>
<li><p>지원되는 하드웨어를 사용해야 함</p></li>
<li><p>시스템이 2014년 이후에 제조되었어야 함</p></li>
<li><p>UEFI를 통해 부팅되어야 함
이러한 방법들을 통해 펌웨어를 안전하고 효율적으로 업데이트할 수 있습니다.<br><br></p></li>
</ul>
<p>버트온은 자체 서명 키를 사용한 보안 부팅 지원을 위해 자체 버전의 fwupd 패키지를 제공합니다. 이 패키지는 하이퍼바이저에서 <code class="docutils literal notranslate"><span class="pre">udisks2</span></code> 패키지 사용 시 발생하는 문제로 인해 의도적으로 <code class="docutils literal notranslate"><span class="pre">udisks2</span></code>에 대한 의존성 권장을 제거했습니다. 따라서 <code class="docutils literal notranslate"><span class="pre">/etc/fwupd/daemon.conf</span></code> 파일에서 EFI 파티션의 올바른 마운트 포인트를 명시적으로 구성해야 합니다. 예를 들면 다음과 같습니다:</p>
<blockquote>
<div><p>[fwupd]<br>
EspLocation=/boot/efi</p>
</div></blockquote>
<p>이렇게 설정함으로써 fwupd가 EFI 시스템 파티션의 위치를 정확히 인식할 수 있게 됩니다. 이는 펌웨어 업데이트 프로세스가 올바르게 작동하는 데 필수적입니다.<br><br></p>
</section>
</section>
<section id="id6">
<h2>3.4. 네트워크 구성<a class="headerlink" href="#id6" title="Link to this heading"><span>#</span></a></h2>
<p>버트온은 Linux 네트워크 스택을 사용합니다. 이를 통해 노드에서 유연하게 네트워크를 설정할 수 있습니다. 설정은 GUI를 통해 수행하거나 전체 네트워크 구성이 포함된 <code class="docutils literal notranslate"><span class="pre">/etc/network/interfaces</span></code>  파일을 직접 편집하여 수행할 수 있습니다. 전체 형식 설명은 <code class="docutils literal notranslate"><span class="pre">interfaces(5)</span></code> 매뉴얼 페이지에서 확인할 수 있습니다. 모든 버트온 관리 도구는 사용자의 직접적인 수정 사항을 유지하려고 노력하지만, 오류를 방지하기 위해 GUI 사용을 권장합니다.<br><br></p>
<p>GuestOS를 기본 물리 네트워크에 연결하려면 Linux 브릿지 인터페이스(일반적으로 <code class="docutils literal notranslate"><span class="pre">vmbrX</span></code>라고 함)가 필요합니다. 이는 GuestOS와 물리 인터페이스가 연결되는 가상 스위치로 생각할 수 있습니다. 이 섹션에서는 <code class="docutils literal notranslate"><span class="pre">bond</span></code>를 통한 이중화, <code class="docutils literal notranslate"><span class="pre">VLAN</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">라우팅</span></code>및 <code class="docutils literal notranslate"><span class="pre">NAT</span></code> 설정과 같은 다양한 사용 사례에 맞게 네트워크를 설정하는 방법에 대한 예시를 제공합니다.<br><br></p>
<p><point>소프트웨어 정의 네트워크(SDN)</point>는 버트온 클러스터에서 더 복잡한 가상 네트워크를 구성하기 위한 옵션입니다.</p>
<blockquote>
<div><p>기본 Debian 도구인 <code class="docutils literal notranslate"><span class="pre">ifup</span></code> 및 <code class="docutils literal notranslate"><span class="pre">ifdown</span></code> 사용은 권장되지 않습니다. 이러한 도구들은 <code class="docutils literal notranslate"><span class="pre">ifdown</span> <span class="pre">vmbrX</span></code> 실행 시 모든 게스트 트래픽을 중단시키고, 이후 동일한 브릿지에서 <code class="docutils literal notranslate"><span class="pre">ifup</span></code>을 실행해도 게스트 연결을 복구하지 않는 등의 문제점이 있습니다.</p>
</div></blockquote>
<p><br><br></p>
<section id="id7">
<h3>3.4.1. 네트워크 변경 사항 적용<a class="headerlink" href="#id7" title="Link to this heading"><span>#</span></a></h3>
<p>버트온은 변경 사항을 <code class="docutils literal notranslate"><span class="pre">/etc/network/interfaces</span></code> 파일에 직접 작성하지 않습니다. 대신 <code class="docutils literal notranslate"><span class="pre">/etc/network/interfaces.new</span></code>라는 임시 파일에 작성합니다. 이를 통해 여러 관련 변경 사항을 한 번에 수행할 수 있습니다. 또한 잘못된 네트워크 구성으로 인해 노드에 접근할 수 없게 되는 상황을 방지하기 위해, 최종적으로 변경 사항이 올바른지 확인할 수 있습니다.<br></p>
<p><point>ifupdown2를 사용한 네트워크 실시간 재 적용</point></p>
<p>권장되는 ifupdown2 패키지(Proxmox VE 7.0 이후 새 설치의 기본값)를 사용하면 재부팅 없이 네트워크 구성 변경 사항을 적용할 수 있습니다. GUI를 통해 네트워크 구성을 변경한 경우, <code class="docutils literal notranslate"><span class="pre">Apply</span> <span class="pre">Configuration</span></code> 버튼을 클릭하면 됩니다. 이 작업은 <code class="docutils literal notranslate"><span class="pre">interfaces.new</span></code> 임시 파일의 변경 사항을 <code class="docutils literal notranslate"><span class="pre">/etc/network/interfaces</span></code>로 이동시키고 실시간으로 적용합니다.<br></p>
<p><code class="docutils literal notranslate"><span class="pre">/etc/network/interfaces</span></code> 파일을 직접 수동으로 변경한 경우, <code class="docutils literal notranslate"><span class="pre">ifreload</span> <span class="pre">-a</span></code>를 실행하여 적용할 수 있습니다.<br><br></p>
</section>
<section id="id8">
<h3>3.4.2. 명명 규칙<a class="headerlink" href="#id8" title="Link to this heading"><span>#</span></a></h3>
<p>현재 다음과 같은 디바이스 이름 명명 규칙을 사용하고 있습니다:</p>
<ul class="simple">
<li><p>이더넷 장치: <code class="docutils literal notranslate"><span class="pre">en*</span></code></p>
<ul>
<li><p>systemd 네트워크 인터페이스 이름</p></li>
<li><p>이 명명 체계는 버트온 5.0 이후 버전에서 사용됩니다.</p></li>
</ul>
</li>
<li><p>이더넷 장치: <code class="docutils literal notranslate"><span class="pre">eth[N]</span></code></p>
<ul>
<li><p>0 ≤ N (<code class="docutils literal notranslate"><span class="pre">eth0,</span> <span class="pre">eth1</span></code>, …)</p></li>
<li><p>이 명명 체계는 버트온 5.0 이전 버전에서 사용됩니다. 5.0 이상 버전으로 업그레이드 시 장치 이름은 그대로 유지됩니다.</p></li>
</ul>
</li>
<li><p>브릿지 이름: 일반적으로 <code class="docutils literal notranslate"><span class="pre">vmbr[N]</span></code></p>
<ul>
<li><p>0 ≤ N ≤ 4094 (<code class="docutils literal notranslate"><span class="pre">vmbr0</span> <span class="pre">-</span> <span class="pre">vmbr4094</span></code>)</p></li>
<li><p>문자로 시작하고 최대 10자 길이의 영숫자 문자열도 사용 가능합니다.</p></li>
</ul>
</li>
<li><p>본드: <code class="docutils literal notranslate"><span class="pre">bond[N]</span></code></p>
<ul>
<li><p>0 ≤ N (<code class="docutils literal notranslate"><span class="pre">bond0,</span> <span class="pre">bond1,</span></code> …)</p></li>
</ul>
</li>
<li><p>VLAN: 장치 이름에 마침표(.)로 구분된 VLAN 번호를 추가합니다 (ex: <code class="docutils literal notranslate"><span class="pre">eno1.50,</span> <span class="pre">bond1.30</span></code>)</p></li>
</ul>
<p>이러한 명명 규칙은 장치 이름이 장치 유형을 암시하므로 네트워크 문제를 디버깅하기 쉽게 만듭니다.<br><br></p>
<p><point>Systemd 네트워크 인터페이스 이름</point></p>
<p>Systemd는 네트워크 장치 이름에 대한 버전 관리 명명 체계를 정의합니다. 이 체계는 이더넷 네트워크 장치에 대해 <code class="docutils literal notranslate"><span class="pre">en</span></code>이라는 두 글자 접두사를 사용합니다. 다음 문자는 장치 드라이버, 장치 위치 및 기타 속성에 따라 달라집니다. 가능한 패턴은 다음과 같습니다:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">o&lt;index&gt;[n&lt;phys_port_name&gt;|d&lt;dev_port&gt;]</span></code>: 온보드(on-board) 장치</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">s&lt;slot&gt;[f&lt;function&gt;][n&lt;phys_port_name&gt;|d&lt;dev_port&gt;]</span></code>: 핫플러그 ID 기반 장치</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[P&lt;domain&gt;]p&lt;bus&gt;s&lt;slot&gt;[f&lt;function&gt;][n&lt;phys_port_name&gt;|d&lt;dev_port&gt;]</span></code>: 버스 ID 기반 장치</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x&lt;MAC&gt;</span></code>:  MAC 주소 기반 장치</p></li>
</ul>
<p>[주요 구성 요소 설명]</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: 장치의 인덱스 번호</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">phys_port_name</span></code>: 물리적 포트 이름</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dev_port</span></code>: 장치 포트 번호</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">slot</span></code>: PCI 슬롯 번호</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">function</span></code>: PCI 기능 번호</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">domain</span></code>: PCI 도메인</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bus</span></code>: PCI 버스 번호</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MAC</span></code>: 장치의 MAC 주소</p></li>
</ul>
<p>네트워크 인터페이스 명명 규칙은 다음과 같은 일반적인 패턴을 사용합니다:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eno1</span></code> — 첫 번째 온보드 NIC(Network Interface Card)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">enp3s0f1</span></code> — PCI 버스 3, 슬롯 0의 NIC의 함수 1
이러한 명명 규칙은 하드웨어 위치와 특성을 기반으로 하여 일관성 있고 예측 가능한 이름을 제공합니다.<br></p></li>
</ul>
<p>새로운 systemd 버전은 새로운 네트워크 인터페이스 명명 체계를 정의할 수 있으며, 이는 기본적으로 사용됩니다. 따라서 버트온 주요 업그레이드와 같은 상황에서 systemd를 새 버전으로 업데이트하면 네트워크 디바이스의 이름이 변경될 수 있으며, 네트워크 구성을 조정해야 할 수 있습니다.<br></p>
<p>명명 체계 버전을 수동으로 고정하여 새 버전으로 인한 이름 변경을 방지할 수 있습니다. 그러나 명명 체계 버전을 고정해도 커널이나 드라이버 업데이트로 인해 네트워크 인터페이스 이름이 여전히 변경될 수 있습니다<br>
특정 네트워크 장치의 이름 변경을 완전히 방지하려면 링크 파일을 사용하여 수동으로 이름을 재정의할 수 있습니다. 이 방법을 통해 장치에 고정된 이름을 지정할 수 있습니다<br></p>
<p><point>특정 명명 체계 버전 고정하기</point><br>
<point>네트워크 장치 이름 재정의하기</point><br></p>
</section>
<section id="id9">
<h3>3.4.3. 네트워크 구성 선택하기<a class="headerlink" href="#id9" title="Link to this heading"><span>#</span></a></h3>
<p>현재 네트워크 구성과 리소스에 따라 브릿지, 라우팅 또는 마스커레이딩 네트워킹 설정 중에서 선택할 수 있습니다.</p>
<p><point>외부 게이트웨이를 통해 인터넷에 연결되는 사설 LAN의 버트온 서버</point></p>
<p>이 경우 <code class="docutils literal notranslate"><span class="pre">브릿지(Bridged)</span></code> 모델이 가장 적합하며, 이는 버트온 첫 설치의 기본 모드이기도 합니다. 각 GuestOS은 버트온 브릿지에 연결된 가상 인터페이스를 갖게 됩니다. 이는 게스트 네트워크 카드가 LAN의 새 스위치에 직접 연결된 것과 유사한 효과를 나타내며, 버트온 호스트가 스위치 역할을 수행합니다.</p>
<p><point>게스트를 위한 공용 IP 범위가 있는 호스팅 제공업체의 버트온 서버</point></p>
<p>이 설정에서는 제공업체가 허용하는 것에 따라 <code class="docutils literal notranslate"><span class="pre">브릿지(Bridged)</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">라우팅(Routed)</span></code> 모델을 사용할 수 있습니다.</p>
<p><point>단일 공용 IP 주소가 있는 호스팅 제공업체의 버트온 서버</point></p>
<p>이 경우 게스트 시스템에 대한 나가는 네트워크 액세스를 얻는 유일한 방법은 마스커레이딩을 사용하는 것입니다. 게스트에 대한 들어오는 네트워크 액세스의 경우 포트 포워딩을 구성해야 합니다.<br></p>
<p>추가 유연성을 위해 VLAN(IEEE 802.1q) 및 “링크 집계”라고도 알려진 네트워크 본딩을 구성할 수 있습니다. 이렇게 하면 복잡하고 유연한 가상 네트워크를 구축할 수 있습니다.<br><br></p>
</section>
<section id="id10">
<h3>3.4.4. 브릿지를 사용한 기본 구성<a class="headerlink" href="#id10" title="Link to this heading"><span>#</span></a></h3>
<p>브릿지는 소프트웨어로 구현된 물리 네트워크 스위치와 같습니다. 모든 가상 게스트가 하나의 브릿지를 공유하거나 네트워크 도메인을 분리하기 위해 여러 개의 브릿지를 만들 수 있습니다. 각 호스트는 최대 4094개의 브릿지를 가질 수 있습니다.<br></p>
<p>설치 프로그램은 첫 번째 이더넷 카드에 연결되는 <point>vmbr0</point>이라는 단일 브릿지를 생성합니다. <point>/etc/network/interfaces</point>의 해당 구성은 다음과 같이 보일 수 있습니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">auto</span> <span class="n">lo</span>
<span class="n">iface</span> <span class="n">lo</span> <span class="n">inet</span> <span class="n">loopback</span>

<span class="n">iface</span> <span class="n">eno1</span> <span class="n">inet</span> <span class="n">manual</span>

<span class="n">auto</span> <span class="n">vmbr0</span>
<span class="n">iface</span> <span class="n">vmbr0</span> <span class="n">inet</span> <span class="n">static</span>
    <span class="n">address</span> <span class="mf">192.168.10.2</span><span class="o">/</span><span class="mi">24</span>
    <span class="n">gateway</span> <span class="mf">192.168.10.1</span>
    <span class="n">bridge</span><span class="o">-</span><span class="n">ports</span> <span class="n">eno1</span>
    <span class="n">bridge</span><span class="o">-</span><span class="n">stp</span> <span class="n">off</span>
    <span class="n">bridge</span><span class="o">-</span><span class="n">fd</span> <span class="mi">0</span>
</pre></div>
</div>
<p>가상 머신은 마치 물리 네트워크에 직접 연결된 것처럼 동작합니다. 네트워크는 모든 가상 머신을 네트워크에 연결하는 네트워크 케이블이 하나만 있어도 각 가상 머신에 고유한 MAC이 있는 것으로 간주합니다.<br><br></p>
</section>
<section id="id11">
<h3>3.4.5 라우팅 구성<a class="headerlink" href="#id11" title="Link to this heading"><span>#</span></a></h3>
<p>대부분의 호스팅 제공업체는 위의 설정을 지원하지 않습니다. 보안상의 이유로 단일 인터페이스에서 여러 MAC 주소를 감지하는 즉시 네트워킹을 비활성화합니다.</p>
<blockquote>
<div><p><img alt="" src="../_images/pin.png" /> 참고<br>
일부 호스팅 제공업체는 관리 인터페이스를 통해 추가 MAC을 등록할 수 있도록 허용합니다. 이렇게 하면 문제를 피할 수 있지만 각 VM에 대해 MAC을 등록해야 하므로 구성이 번거로울 수 있습니다.
단일 인터페이스를 통해 모든 트래픽을 ‘라우팅’하면 이 문제를 피할 수 있습니다. 이렇게 하면 모든 네트워크 패킷이 동일한 MAC 주소를 사용하도록 할 수 있습니다.</p>
</div></blockquote>
<p>일반적인 시나리오는 공용 IP(예시로는 <point>198.51.100.5</point>로 가정)와 VM을 위한 추가 IP(<point>203.0.113.16/28</point>)이 있는 경우입니다. 이러한 상황에는 다음 설정을 권장합니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">auto</span> <span class="n">lo</span>
<span class="n">iface</span> <span class="n">lo</span> <span class="n">inet</span> <span class="n">loopback</span>

<span class="n">auto</span> <span class="n">eno0</span>
<span class="n">iface</span> <span class="n">eno0</span> <span class="n">inet</span> <span class="n">static</span>
        <span class="n">address</span>  <span class="mf">198.51.100.5</span><span class="o">/</span><span class="mi">29</span>
        <span class="n">gateway</span>  <span class="mf">198.51.100.1</span>
        <span class="n">post</span><span class="o">-</span><span class="n">up</span> <span class="n">echo</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="o">/</span><span class="n">proc</span><span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">net</span><span class="o">/</span><span class="n">ipv4</span><span class="o">/</span><span class="n">ip_forward</span>
        <span class="n">post</span><span class="o">-</span><span class="n">up</span> <span class="n">echo</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="o">/</span><span class="n">proc</span><span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">net</span><span class="o">/</span><span class="n">ipv4</span><span class="o">/</span><span class="n">conf</span><span class="o">/</span><span class="n">eno0</span><span class="o">/</span><span class="n">proxy_arp</span>


<span class="n">auto</span> <span class="n">vmbr0</span>
<span class="n">iface</span> <span class="n">vmbr0</span> <span class="n">inet</span> <span class="n">static</span>
        <span class="n">address</span>  <span class="mf">203.0.113.17</span><span class="o">/</span><span class="mi">28</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">ports</span> <span class="n">none</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">stp</span> <span class="n">off</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">fd</span> <span class="mi">0</span>
</pre></div>
</div>
<br>
### 3.4.6 iptables를 사용한 마스커레이딩(NAT) 
마스커레이딩을 사용하면 개인 IP 주소만 있는 게스트가 발신 트래픽에 호스트 IP 주소를 사용하여 네트워크에 액세스할 수 있습니다. 각 발신 패킷은 호스트에서 발신한 것처럼 보이도록 <point>iptables</point>에 의해 재작성되고, 그에 따라 응답이 원래 발신자에게 라우팅되도록 재작성됩니다.
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">auto</span> <span class="n">lo</span>
<span class="n">iface</span> <span class="n">lo</span> <span class="n">inet</span> <span class="n">loopback</span>

<span class="n">auto</span> <span class="n">eno1</span>
<span class="c1">#real IP address</span>
<span class="n">iface</span> <span class="n">eno1</span> <span class="n">inet</span> <span class="n">static</span>
        <span class="n">address</span>  <span class="mf">198.51.100.5</span><span class="o">/</span><span class="mi">24</span>
        <span class="n">gateway</span>  <span class="mf">198.51.100.1</span>

<span class="n">auto</span> <span class="n">vmbr0</span>
<span class="c1">#private sub network</span>
<span class="n">iface</span> <span class="n">vmbr0</span> <span class="n">inet</span> <span class="n">static</span>
        <span class="n">address</span>  <span class="mf">10.10.10.1</span><span class="o">/</span><span class="mi">24</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">ports</span> <span class="n">none</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">stp</span> <span class="n">off</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">fd</span> <span class="mi">0</span>

        <span class="n">post</span><span class="o">-</span><span class="n">up</span>   <span class="n">echo</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="o">/</span><span class="n">proc</span><span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">net</span><span class="o">/</span><span class="n">ipv4</span><span class="o">/</span><span class="n">ip_forward</span>
        <span class="n">post</span><span class="o">-</span><span class="n">up</span>   <span class="n">iptables</span> <span class="o">-</span><span class="n">t</span> <span class="n">nat</span> <span class="o">-</span><span class="n">A</span> <span class="n">POSTROUTING</span> <span class="o">-</span><span class="n">s</span> <span class="s1">&#39;10.10.10.0/24&#39;</span> <span class="o">-</span><span class="n">o</span> <span class="n">eno1</span> <span class="o">-</span><span class="n">j</span> <span class="n">MASQUERADE</span>
        <span class="n">post</span><span class="o">-</span><span class="n">down</span> <span class="n">iptables</span> <span class="o">-</span><span class="n">t</span> <span class="n">nat</span> <span class="o">-</span><span class="n">D</span> <span class="n">POSTROUTING</span> <span class="o">-</span><span class="n">s</span> <span class="s1">&#39;10.10.10.0/24&#39;</span> <span class="o">-</span><span class="n">o</span> <span class="n">eno1</span> <span class="o">-</span><span class="n">j</span> <span class="n">MASQUERADE</span>
</pre></div>
</div>
<blockquote>
<div><p><img alt="" src="../_images/pin.png" /> 참고<br>
방화벽이 활성화된 일부 마스커레이드 설정에서는 나가는 연결에 컨트랙트 영역이 필요할 수 있습니다. 그렇지 않으면 방화벽이 <point>마스커레이드</point>가 아닌 VM 브릿지의 <point>포스트라우팅</point>을 선호하기 때문에 나가는 연결을 차단할 수 있습니다.</p>
</div></blockquote>
<p><point>/etc/network/interfaces</point>에 이 줄을 추가하면 이 문제를 해결할 수 있습니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">post</span><span class="o">-</span><span class="n">up</span>   <span class="n">iptables</span> <span class="o">-</span><span class="n">t</span> <span class="n">raw</span> <span class="o">-</span><span class="n">I</span> <span class="n">PREROUTING</span> <span class="o">-</span><span class="n">i</span> <span class="n">fwbr</span><span class="o">+</span> <span class="o">-</span><span class="n">j</span> <span class="n">CT</span> <span class="o">--</span><span class="n">zone</span> <span class="mi">1</span>
<span class="n">post</span><span class="o">-</span><span class="n">down</span> <span class="n">iptables</span> <span class="o">-</span><span class="n">t</span> <span class="n">raw</span> <span class="o">-</span><span class="n">D</span> <span class="n">PREROUTING</span> <span class="o">-</span><span class="n">i</span> <span class="n">fwbr</span><span class="o">+</span> <span class="o">-</span><span class="n">j</span> <span class="n">CT</span> <span class="o">--</span><span class="n">zone</span> <span class="mi">1</span>
</pre></div>
</div>
</section>
<section id="linux-bond">
<h3>3.4.7 Linux Bond<a class="headerlink" href="#linux-bond" title="Link to this heading"><span>#</span></a></h3>
<p>본딩(NIC 티밍 또는 링크 집계라고도 함)은 여러 NIC를 단일 네트워크 장치에 바인딩하는 기술입니다. 네트워크 내결함성 확보, 성능 향상 또는 두 가지 목표를 함께 달성하는 등 다양한 목표를 달성할 수 있습니다.<br>
파이버 채널(FC)과 같은 고속 하드웨어와 관련 스위칭 하드웨어는 상당히 비쌀 수 있습니다. 링크 집계를 수행하면 두 개의 NIC를 하나의 논리적 인터페이스로 표시하여 속도를 두 배로 높일 수 있습니다. 이는 대부분의 스위치에서 지원되는 기본 Linux 커널 기능입니다. 노드에 이더넷 포트가 여러 개 있는 경우 네트워크 케이블을 다른 스위치로 연결하여 장애 지점을 분산할 수 있으며, 네트워크 문제 발생 시 본딩된 연결이 한 케이블 또는 다른 케이블로 페일오버됩니다.<br></p>
<p>집계된 링크는 라이브 마이그레이션의 지연을 개선하고 Proxmox VE 클러스터 노드 간의 데이터 복제 속도를 향상시킬 수 있습니다.<br></p>
<p>본딩에는 7가지 모드가 있습니다:</p>
<ul class="simple">
<li><p><point>Round-robin (balance-rr)</point></p>
<ul>
<li><p>사용 가능한 첫 번째 네트워크 인터페이스(NIC) 슬레이브부터 마지막 슬레이브까지 순차적인 순서로 네트워크 패킷을 전송합니다.</p></li>
<li><p>이 모드는 부하 분산 및 내결함성을 제공합니다.</p></li>
</ul>
</li>
<li><p><point>Active-backup (active-backup)</point></p>
<ul>
<li><p>본드에서 하나의 NIC 슬레이브만 활성화됩니다. 활성 슬레이브에 장애가 발생하는 경우에만 다른 슬레이브가 활성화됩니다.</p></li>
<li><p>네트워크 스위치의 왜곡을 방지하기 위해 단일 논리적 본드 인터페이스의 MAC 주소는 하나의 NIC(포트)에서만 외부에 표시됩니다.</p></li>
<li><p>이 모드는 내결함성을 제공합니다.</p></li>
</ul>
</li>
<li><p><point>XOR (balance-xor)</point></p>
<ul>
<li><p>[(소스 MAC 주소와 대상 MAC 주소를 XOR한) 모듈로 NIC 슬레이브 수]를 기준으로 네트워크 패킷을 전송합니다. 이 모드는 각 대상 MAC 주소에 대해 동일한 NIC 슬레이브를 선택합니다.</p></li>
<li><p>이 모드는 부하 분산 및 내결함성을 제공합니다.</p></li>
</ul>
</li>
<li><p><point>브로드캐스트 (broadcast)</point></p>
<ul>
<li><p>모든 슬레이브 네트워크 인터페이스에서 네트워크 패킷을 전송합니다.</p></li>
<li><p>이 모드는 내결함성을 제공합니다.</p></li>
</ul>
</li>
<li><p><point>IEEE 802.3ad Dynamic link aggregation (802.3ad)(LACP)</point></p>
<ul>
<li><p>동일한 속도 및 이중 설정을 공유하는 집계 그룹을 생성합니다.</p></li>
<li><p>802.3ad 사양에 따라 활성 애그리게이터 그룹의 모든 슬레이브 네트워크 인터페이스를 활용합니다.</p></li>
</ul>
</li>
<li><p><point>적응형 전송 부하 분산 (balance-tlb)</point></p>
<ul>
<li><p>특별한 네트워크 스위치 지원이 필요하지 않은 Linux 본딩 드라이버 모드입니다.</p></li>
<li><p>나가는 네트워크 패킷 트래픽은 각 네트워크 인터페이스 슬레이브의 현재 부하(속도에 따라 계산됨)에 따라 분산됩니다. 들어오는 트래픽은 현재 지정된 하나의 슬레이브 네트워크 인터페이스에서 수신됩니다.</p></li>
<li><p>이 수신 슬레이브에 장애가 발생하면 다른 슬레이브가 장애가 발생한 수신 슬레이브의 MAC 주소를 이어받습니다.</p></li>
</ul>
</li>
<li><p><point>적응형 부하 분산 (balance-alb)</point></p>
<ul>
<li><p>PV4 트래픽에 대한 balance-tlb와 수신 부하 분산(rlb)을 포함하며, 특별한 네트워크 스위치 지원이 필요하지 않습니다. 수신 부하 분산은 ARP 협상을 통해 이루어집니다.</p></li>
<li><p>본딩 드라이버는 로컬 시스템에서 보내는 ARP 응답을 가로채서 소스 하드웨어 주소를 단일 논리적 본딩 인터페이스의 NIC 슬레이브 중 하나의 고유 하드웨어 주소로 덮어쓰므로 서로 다른 네트워크 피어가 네트워크 패킷 트래픽에 다른 MAC 주소를 사용합니다.
<br>
스위치가 LACP(IEEE 802.3ad) 프로토콜을 지원하는 경우 해당 본딩 모드(802.3ad)를 사용하는 것이 좋습니다. 그렇지 않은 경우에는 일반적으로 active-backup 모드를 사용해야 합니다.<br></p></li>
</ul>
</li>
</ul>
<p>클러스터 네트워크(<point>Corosync</point>)의 경우 여러 네트워크로 구성하는 것이 좋습니다. Corosync는 네트워크 중 하나를 사용할 수 없게 되는 경우 자체적으로 네트워크 간에 전환할 수 있으므로 네트워크 이중화를 위한 본드가 필요하지 않습니다.<br></p>
<p>다음 본딩 구성은 분산/공유 스토리지 네트워크로 사용할 수 있습니다. 이 경우 속도가 빨라지고 네트워크가 내결함성을 갖게 된다는 이점이 있습니다.<br><br></p>
<p><point><img alt="" src="../_images/pin.png" /> 예시: 고정 IP로 본딩 사용</point></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">auto</span> <span class="n">lo</span>
<span class="n">iface</span> <span class="n">lo</span> <span class="n">inet</span> <span class="n">loopback</span>

<span class="n">iface</span> <span class="n">eno1</span> <span class="n">inet</span> <span class="n">manual</span>

<span class="n">iface</span> <span class="n">eno2</span> <span class="n">inet</span> <span class="n">manual</span>

<span class="n">iface</span> <span class="n">eno3</span> <span class="n">inet</span> <span class="n">manual</span>

<span class="n">auto</span> <span class="n">bond0</span>
<span class="n">iface</span> <span class="n">bond0</span> <span class="n">inet</span> <span class="n">static</span>
      <span class="n">bond</span><span class="o">-</span><span class="n">slaves</span> <span class="n">eno1</span> <span class="n">eno2</span>
      <span class="n">address</span>  <span class="mf">192.168.1.2</span><span class="o">/</span><span class="mi">24</span>
      <span class="n">bond</span><span class="o">-</span><span class="n">miimon</span> <span class="mi">100</span>
      <span class="n">bond</span><span class="o">-</span><span class="n">mode</span> <span class="mf">802.3</span><span class="n">ad</span>
      <span class="n">bond</span><span class="o">-</span><span class="n">xmit</span><span class="o">-</span><span class="nb">hash</span><span class="o">-</span><span class="n">policy</span> <span class="n">layer2</span><span class="o">+</span><span class="mi">3</span>

<span class="n">auto</span> <span class="n">vmbr0</span>
<span class="n">iface</span> <span class="n">vmbr0</span> <span class="n">inet</span> <span class="n">static</span>
        <span class="n">address</span>  <span class="mf">10.10.10.2</span><span class="o">/</span><span class="mi">24</span>
        <span class="n">gateway</span>  <span class="mf">10.10.10.1</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">ports</span> <span class="n">eno3</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">stp</span> <span class="n">off</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">fd</span> <span class="mi">0</span>
</pre></div>
</div>
<br>
<p>또 다른 가능성은 본딩을 브릿지 포트로 직접 사용하는 것입니다. 이는 게스트 네트워크에 내결함성을 부여하는 데 사용할 수 있습니다.<br></p>
<p><point><img alt="" src="../_images/pin.png" /> 예시: 브릿지 포트로 본딩 사용</point></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">auto</span> <span class="n">lo</span>
<span class="n">iface</span> <span class="n">lo</span> <span class="n">inet</span> <span class="n">loopback</span>

<span class="n">iface</span> <span class="n">eno1</span> <span class="n">inet</span> <span class="n">manual</span>

<span class="n">iface</span> <span class="n">eno2</span> <span class="n">inet</span> <span class="n">manual</span>

<span class="n">auto</span> <span class="n">bond0</span>
<span class="n">iface</span> <span class="n">bond0</span> <span class="n">inet</span> <span class="n">manual</span>
      <span class="n">bond</span><span class="o">-</span><span class="n">slaves</span> <span class="n">eno1</span> <span class="n">eno2</span>
      <span class="n">bond</span><span class="o">-</span><span class="n">miimon</span> <span class="mi">100</span>
      <span class="n">bond</span><span class="o">-</span><span class="n">mode</span> <span class="mf">802.3</span><span class="n">ad</span>
      <span class="n">bond</span><span class="o">-</span><span class="n">xmit</span><span class="o">-</span><span class="nb">hash</span><span class="o">-</span><span class="n">policy</span> <span class="n">layer2</span><span class="o">+</span><span class="mi">3</span>

<span class="n">auto</span> <span class="n">vmbr0</span>
<span class="n">iface</span> <span class="n">vmbr0</span> <span class="n">inet</span> <span class="n">static</span>
        <span class="n">address</span>  <span class="mf">10.10.10.2</span><span class="o">/</span><span class="mi">24</span>
        <span class="n">gateway</span>  <span class="mf">10.10.10.1</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">ports</span> <span class="n">bond0</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">stp</span> <span class="n">off</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">fd</span> <span class="mi">0</span>
</pre></div>
</div>
</section>
<section id="vlan-802-1q">
<h3>3.4.8. VLAN 802.1Q<a class="headerlink" href="#vlan-802-1q" title="Link to this heading"><span>#</span></a></h3>
<p>가상 LAN(VLAN)은 네트워크 상에서 레이어2에서 분할되고 격리된 브로드캐스트 도메인입니다. 따라서 물리 네트워크에 각각 다른 네트워크와 독립적인 여러 네트워크(4096개)를 가질 수 있습니다.<br></p>
<p>각 VLAN 네트워크는 흔히 <point>태그</point>라고 하는 번호로 식별됩니다. 그런 다음 네트워크 패키지에 <point>태그</point>를 지정하여 해당 네트워크가 속한 가상 네트워크를 식별합니다.<br><br></p>
<p><point><img alt="" src="../_images/pin.png" /> 게스트 네트워크용 VLAN</point><br>
Proxmox VE는 이 설정을 기본으로 지원합니다. VM을 생성할 때 VLAN 태그를 지정할 수 있습니다. VLAN 태그는 게스트 네트워크 구성의 일부입니다. 네트워킹 계층은 브리지 구성에 따라 다양한 모드를 지원하여 VLAN을 구현합니다:</p>
<ul class="simple">
<li><p>Linux 브릿지에서 VLAN 인식</p>
<ul>
<li><p>이 경우 각 게스트의 가상 네트워크 카드가 Linux 브릿지에서 투명하게 지원되는 VLAN 태그에 할당됩니다. 트렁크(Trunk) 모드도 가능하지만 이 경우 게스트에서 구성이 필요합니다.</p></li>
</ul>
</li>
<li><p>Linux 브리지의 “기존” VLAN</p>
<ul>
<li><p>이 방법은 VLAN 인식 방법과 달리 투명하지 않으며 각 VLAN에 대해 연결된 브리지가 있는 VLAN 장치를 만듭니다.</p></li>
<li><p>즉, 예를 들어 VLAN 5에 게스트를 생성하면 재부팅할 때까지 유지되는 두 개의 인터페이스 eno1.5 및 vmbr0v5가 생성됩니다.</p></li>
</ul>
</li>
<li><p>Open vSwitch VLAN</p>
<ul>
<li><p>이 모드는 OVS VLAN 기능을 사용합니다.</p></li>
</ul>
</li>
<li><p>게스트 구성 VLAN</p>
<ul>
<li><p>게스트 내부에 VLAN이 할당됩니다. 이 경우 설정이 게스트 내부에서 완전히 이루어지며 외부에서 영향을 받을 수 없습니다.</p></li>
<li><p>단일 가상 NIC에서 둘 이상의 VLAN을 사용할 수 있다는 장점이 있습니다.
<br><br></p></li>
</ul>
</li>
</ul>
<p><point><img alt="" src="../_images/pin.png" /> 호스트의 VLAN</point><br>
호스트가 격리된 네트워크와 통신할 수 있도록 허용합니다. 모든 네트워크 장치(NIC, 본딩, 브릿지)에 VLAN 태그를 적용할 수 있습니다. 일반적으로 VLAN은 물리적 NIC와의 사이에 추상화 계층이 가장 적은 인터페이스에 구성해야 합니다.<br>
예를 들어 호스트 관리 주소를 별도의 VLAN에 배치하려는 기본 구성의 경우입니다.<br>&gt;<br></p>
<p><point><img alt="" src="../_images/pin.png" /> 예시: 기존 Linux 브릿지를 사용하여 Proxmox VE 관리 IP에 VLAN 5 사용</point><br></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">auto</span> <span class="n">lo</span>
<span class="n">iface</span> <span class="n">lo</span> <span class="n">inet</span> <span class="n">loopback</span>

<span class="n">iface</span> <span class="n">eno1</span> <span class="n">inet</span> <span class="n">manual</span>

<span class="n">iface</span> <span class="n">eno1</span><span class="mf">.5</span> <span class="n">inet</span> <span class="n">manual</span>

<span class="n">auto</span> <span class="n">vmbr0v5</span>
<span class="n">iface</span> <span class="n">vmbr0v5</span> <span class="n">inet</span> <span class="n">static</span>
        <span class="n">address</span>  <span class="mf">10.10.10.2</span><span class="o">/</span><span class="mi">24</span>
        <span class="n">gateway</span>  <span class="mf">10.10.10.1</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">ports</span> <span class="n">eno1</span><span class="mf">.5</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">stp</span> <span class="n">off</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">fd</span> <span class="mi">0</span>

<span class="n">auto</span> <span class="n">vmbr0</span>
<span class="n">iface</span> <span class="n">vmbr0</span> <span class="n">inet</span> <span class="n">manual</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">ports</span> <span class="n">eno1</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">stp</span> <span class="n">off</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">fd</span> <span class="mi">0</span>
</pre></div>
</div>
<p><point><img alt="" src="../_images/pin.png" /> 예시: VLAN 인식 Linux 브릿지를 사용하여 Proxmox VE 관리 IP에 VLAN 5 사용</point><br></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">auto</span> <span class="n">lo</span>
<span class="n">iface</span> <span class="n">lo</span> <span class="n">inet</span> <span class="n">loopback</span>

<span class="n">iface</span> <span class="n">eno1</span> <span class="n">inet</span> <span class="n">manual</span>


<span class="n">auto</span> <span class="n">vmbr0</span><span class="mf">.5</span>
<span class="n">iface</span> <span class="n">vmbr0</span><span class="mf">.5</span> <span class="n">inet</span> <span class="n">static</span>
        <span class="n">address</span>  <span class="mf">10.10.10.2</span><span class="o">/</span><span class="mi">24</span>
        <span class="n">gateway</span>  <span class="mf">10.10.10.1</span>

<span class="n">auto</span> <span class="n">vmbr0</span>
<span class="n">iface</span> <span class="n">vmbr0</span> <span class="n">inet</span> <span class="n">manual</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">ports</span> <span class="n">eno1</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">stp</span> <span class="n">off</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">fd</span> <span class="mi">0</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">vlan</span><span class="o">-</span><span class="n">aware</span> <span class="n">yes</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">vids</span> <span class="mi">2</span><span class="o">-</span><span class="mi">4094</span>
</pre></div>
</div>
<p>다음 예는 동일한 설정이지만, 네트워크 장애로부터 안전하게 보호하기 위해 본딩를 사용합니다.<br></p>
<p><point><img alt="" src="../_images/pin.png" /> 예시: 기존 Linux 브릿지를 사용하여 Proxmox VE 관리 IP에 bond0을 사용하여 VLAN 5 사용</point><br></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">auto</span> <span class="n">lo</span>
<span class="n">iface</span> <span class="n">lo</span> <span class="n">inet</span> <span class="n">loopback</span>

<span class="n">iface</span> <span class="n">eno1</span> <span class="n">inet</span> <span class="n">manual</span>

<span class="n">iface</span> <span class="n">eno2</span> <span class="n">inet</span> <span class="n">manual</span>

<span class="n">auto</span> <span class="n">bond0</span>
<span class="n">iface</span> <span class="n">bond0</span> <span class="n">inet</span> <span class="n">manual</span>
      <span class="n">bond</span><span class="o">-</span><span class="n">slaves</span> <span class="n">eno1</span> <span class="n">eno2</span>
      <span class="n">bond</span><span class="o">-</span><span class="n">miimon</span> <span class="mi">100</span>
      <span class="n">bond</span><span class="o">-</span><span class="n">mode</span> <span class="mf">802.3</span><span class="n">ad</span>
      <span class="n">bond</span><span class="o">-</span><span class="n">xmit</span><span class="o">-</span><span class="nb">hash</span><span class="o">-</span><span class="n">policy</span> <span class="n">layer2</span><span class="o">+</span><span class="mi">3</span>

<span class="n">iface</span> <span class="n">bond0</span><span class="mf">.5</span> <span class="n">inet</span> <span class="n">manual</span>

<span class="n">auto</span> <span class="n">vmbr0v5</span>
<span class="n">iface</span> <span class="n">vmbr0v5</span> <span class="n">inet</span> <span class="n">static</span>
        <span class="n">address</span>  <span class="mf">10.10.10.2</span><span class="o">/</span><span class="mi">24</span>
        <span class="n">gateway</span>  <span class="mf">10.10.10.1</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">ports</span> <span class="n">bond0</span><span class="mf">.5</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">stp</span> <span class="n">off</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">fd</span> <span class="mi">0</span>

<span class="n">auto</span> <span class="n">vmbr0</span>
<span class="n">iface</span> <span class="n">vmbr0</span> <span class="n">inet</span> <span class="n">manual</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">ports</span> <span class="n">bond0</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">stp</span> <span class="n">off</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">fd</span> <span class="mi">0</span>
</pre></div>
</div>
</section>
<section id="ipv6">
<h3>3.4.9. 노드에서 IPv6 비활성화하기<a class="headerlink" href="#ipv6" title="Link to this heading"><span>#</span></a></h3>
<p>Proxmox VE는 IPv6 배포 여부에 관계없이 모든 환경에서 올바르게 작동합니다. 모든 설정을 제공된 기본값으로 두는 것이 좋습니다.<br></p>
<p>그래도 노드에서 IPv6 지원을 비활성화해야 하는 경우, 적절한 <point>sysctl.conf(5)</point> 스니펫 파일을 생성하고 <point>/etc/sysctl.d/disable-ipv6.conf</point>에 내용을 추가하는 등 적절한 <point>sysctls</point>를 설정하여 비활성화할 수 있습니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">net</span><span class="o">.</span><span class="n">ipv6</span><span class="o">.</span><span class="n">conf</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">disable_ipv6</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">net</span><span class="o">.</span><span class="n">ipv6</span><span class="o">.</span><span class="n">conf</span><span class="o">.</span><span class="n">default</span><span class="o">.</span><span class="n">disable_ipv6</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>이 방법은 커널 명령줄에서 IPv6 모듈의 로딩을 비활성화하는 것보다 선호됩니다.</p>
</section>
<section id="mac">
<h3>3.4.10. 브릿지에서 MAC 학습 기능 비활성화하기<a class="headerlink" href="#mac" title="Link to this heading"><span>#</span></a></h3>
<p>기본적으로 MAC 학습 기능은 가상 게스트 및 해당 네트워크와의 원활한 환경을 보장하기 위해 브릿지에서 사용하도록 설정되어 있습니다.<br></p>
<p>그러나 일부 환경에서는 원하지 않을 수 있습니다. Proxmox VE 7.3부터는 예를 들어 <code class="docutils literal notranslate"><span class="pre">/etc/network/interfaces’의</span> <span class="pre">브리지에서</span> <span class="pre">‘bridge-disable-mac-learning</span> <span class="pre">1</span></code> 구성을 설정하여 브릿지에서 MAC 학습을 비활성화할 수 있습니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># ...</span>

<span class="n">auto</span> <span class="n">vmbr0</span>
<span class="n">iface</span> <span class="n">vmbr0</span> <span class="n">inet</span> <span class="n">static</span>
        <span class="n">address</span>  <span class="mf">10.10.10.2</span><span class="o">/</span><span class="mi">24</span>
        <span class="n">gateway</span>  <span class="mf">10.10.10.1</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">ports</span> <span class="n">ens18</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">stp</span> <span class="n">off</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">fd</span> <span class="mi">0</span>
        <span class="n">bridge</span><span class="o">-</span><span class="n">disable</span><span class="o">-</span><span class="n">mac</span><span class="o">-</span><span class="n">learning</span> <span class="mi">1</span>
</pre></div>
</div>
<p>활성화되면 Proxmox VE는 VM 및 컨테이너에서 구성된 MAC 주소를 수동으로 브릿지 포워딩 데이터베이스에 추가하여 게스트가 네트워크를 계속 사용할 수 있도록 하지만 실제 MAC 주소를 사용하는 경우에만 네트워크를 사용할 수 있도록 합니다.<br></p>
</section>
</section>
<section id="id12">
<h2>3.5. 시간 동기화<a class="headerlink" href="#id12" title="Link to this heading"><span>#</span></a></h2>
<p>Proxmox VE 클러스터 스택 자체는 모든 노드의 시간이 정확하게 동기화되어 있다는 사실에 크게 의존합니다. 모든 노드의 현지 시간이 동기화되지 않으면 Ceph와 같은 일부 다른 구성 요소도 제대로 작동하지 않습니다.<br>
노드 간의 시간 동기화는 <point>“Network Time Protocol”(NTP)</point>을 사용하여 수행할 수 있습니다. Proxmox VE 7부터는 <point>chrony</point>가 기본 NTP 서비스로 사용되며, Proxmox VE 6은 <point>systemd-timesyncd</point>를 사용합니다. 둘 다 공용 서버 세트를 사용하도록 사전 구성되어 제공됩니다.<br></p>
<blockquote>
<div><p><img alt="" src="../_images/pin.png" /> 시스템을 Proxmox VE 7로 업그레이드하는 경우 <point>chrony, ntp</point> 또는 <point>openntpd</point> 중 하나를 수동으로 설치하는 것이 좋습니다.
<br></p>
</div></blockquote>
<section id="ntp">
<h3>3.5.1. 사용자 지정 NTP 서버 사용<a class="headerlink" href="#ntp" title="Link to this heading"><span>#</span></a></h3>
<p>경우에 따라 기본값이 아닌 NTP 서버를 사용해야 할 수도 있습니다. 예를 들어, 제한적인 방화벽 규칙으로 인해 공용 인터넷에 액세스할 수 없는 경우 로컬 NTP 서버를 설정하고 NTP 서비스에 이를 사용하도록 지시해야 합니다.<br><br></p>
<p><point><img alt="" src="../_images/pin.png" /> chrony를 사용하는 시스템의 경우:</point><br>
<point>etc/chrony/chrony.conf</point>에서 <point>chrony</point>가 사용할 서버를 지정합니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">server</span> <span class="n">ntp1</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">com</span> <span class="n">iburst</span>
<span class="n">server</span> <span class="n">ntp2</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">com</span> <span class="n">iburst</span>
<span class="n">server</span> <span class="n">ntp3</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">com</span> <span class="n">iburst</span>
</pre></div>
</div>
<p><point>chrony</point>를 재시작합니다.<br></p>
<p>|# systemctl restart chronyd</p>
<p>저널을 확인하여 새로 구성된 NTP 서버가 사용되고 있는지 확인합니다.<br>
|# journalctl –since -1h -u chrony</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="n">Aug</span> <span class="mi">26</span> <span class="mi">13</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">09</span> <span class="n">node1</span> <span class="n">systemd</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">Started</span> <span class="n">chrony</span><span class="p">,</span> <span class="n">an</span> <span class="n">NTP</span> <span class="n">client</span><span class="o">/</span><span class="n">server</span><span class="o">.</span>
<span class="n">Aug</span> <span class="mi">26</span> <span class="mi">13</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">15</span> <span class="n">node1</span> <span class="n">chronyd</span><span class="p">[</span><span class="mi">4873</span><span class="p">]:</span> <span class="n">Selected</span> <span class="n">source</span> <span class="mf">10.0.0.1</span> <span class="p">(</span><span class="n">ntp1</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">com</span><span class="p">)</span>
<span class="n">Aug</span> <span class="mi">26</span> <span class="mi">13</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">15</span> <span class="n">node1</span> <span class="n">chronyd</span><span class="p">[</span><span class="mi">4873</span><span class="p">]:</span> <span class="n">System</span> <span class="n">clock</span> <span class="n">TAI</span> <span class="n">offset</span> <span class="nb">set</span> <span class="n">to</span> <span class="mi">37</span> <span class="n">seconds</span>
<span class="o">...</span>
</pre></div>
</div>
<p><point><img alt="" src="../_images/pin.png" /> systemd-timesyncd를 사용하는 시스템의 경우:</point><br>
<point>etc/systemd/timesyncd.conf</point>에서 <point>systemd-timesyncd</point>가 사용할 서버를 지정합니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">Time</span><span class="p">]</span>
<span class="n">NTP</span><span class="o">=</span><span class="n">ntp1</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">com</span> <span class="n">ntp2</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">com</span> <span class="n">ntp3</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">com</span> <span class="n">ntp4</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">com</span>
</pre></div>
</div>
<p>그런 다음 동기화 서비스를 다시 시작하고(<point>systemctl restart systemd-timesyncd</point>), 저널을 확인하여 새로 구성한 NTP 서버가 사용 중인지 확인합니다(<point>journalctl –since -1h -u systemd-timesyncd</point>).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="n">Oct</span> <span class="mi">07</span> <span class="mi">14</span><span class="p">:</span><span class="mi">58</span><span class="p">:</span><span class="mi">36</span> <span class="n">node1</span> <span class="n">systemd</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">Stopping</span> <span class="n">Network</span> <span class="n">Time</span> <span class="n">Synchronization</span><span class="o">...</span>
<span class="n">Oct</span> <span class="mi">07</span> <span class="mi">14</span><span class="p">:</span><span class="mi">58</span><span class="p">:</span><span class="mi">36</span> <span class="n">node1</span> <span class="n">systemd</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">Starting</span> <span class="n">Network</span> <span class="n">Time</span> <span class="n">Synchronization</span><span class="o">...</span>
<span class="n">Oct</span> <span class="mi">07</span> <span class="mi">14</span><span class="p">:</span><span class="mi">58</span><span class="p">:</span><span class="mi">36</span> <span class="n">node1</span> <span class="n">systemd</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">Started</span> <span class="n">Network</span> <span class="n">Time</span> <span class="n">Synchronization</span><span class="o">.</span>
<span class="n">Oct</span> <span class="mi">07</span> <span class="mi">14</span><span class="p">:</span><span class="mi">58</span><span class="p">:</span><span class="mi">36</span> <span class="n">node1</span> <span class="n">systemd</span><span class="o">-</span><span class="n">timesyncd</span><span class="p">[</span><span class="mi">13514</span><span class="p">]:</span> <span class="n">Using</span> <span class="n">NTP</span> <span class="n">server</span> <span class="mf">10.0.0.1</span><span class="p">:</span><span class="mi">123</span> <span class="p">(</span><span class="n">ntp1</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">com</span><span class="p">)</span><span class="o">.</span>
<span class="n">Oct</span> <span class="mi">07</span> <span class="mi">14</span><span class="p">:</span><span class="mi">58</span><span class="p">:</span><span class="mi">36</span> <span class="n">node1</span> <span class="n">systemd</span><span class="o">-</span><span class="n">timesyncd</span><span class="p">[</span><span class="mi">13514</span><span class="p">]:</span> <span class="n">interval</span><span class="o">/</span><span class="n">delta</span><span class="o">/</span><span class="n">delay</span><span class="o">/</span><span class="n">jitter</span><span class="o">/</span><span class="n">drift</span> <span class="mi">64</span><span class="n">s</span><span class="o">/-</span><span class="mf">0.002</span><span class="n">s</span><span class="o">/</span><span class="mf">0.020</span><span class="n">s</span><span class="o">/</span><span class="mf">0.000</span><span class="n">s</span><span class="o">/-</span><span class="mi">31</span><span class="n">ppm</span>
<span class="o">...</span>
</pre></div>
</div>
</section>
</section>
<section id="id13">
<h2>3.6. 외부 메트릭 서버<a class="headerlink" href="#id13" title="Link to this heading"><span>#</span></a></h2>
<p>Proxmox VE에서는 호스트, 가상 게스트 및 스토리지에 대한 다양한 통계를 주기적으로 수신하는 외부 메트릭 서버를 정의할 수 있습니다.<br>
현재 지원되는 서버는 다음과 같습니다:</p>
<ul class="simple">
<li><p>Graphite (https://graphiteapp.org/ 참조)</p></li>
<li><p>InfluxDB (https://www.influxdata.com/time-series-platform/influxdb/ 참조)
<br></p></li>
</ul>
<p>외부 메트릭 서버 정의는 <point>/etc/pve/status.cfg</point>에 저장되며, 웹 인터페이스를 통해 편집할 수 있습니다.<br><br></p>
<section id="graphite">
<h3>3.6.1. Graphite 서버 구성<a class="headerlink" href="#graphite" title="Link to this heading"><span>#</span></a></h3>
<p>기본 포트는 <point>2003</point>으로 설정되어 있으며 기본 그래파이트(Graphite) 경로는 <point>proxmox</point>입니다.<br>
기본적으로 Proxmox VE는 UDP를 통해 데이터를 전송하므로 이를 허용하도록 그래파이트 서버를 구성해야 합니다. 여기에서 표준 <point>1500</point> MTU를 사용하지 않는 환경에 대해 최대 전송 단위(MTU)를 구성할 수 있습니다.<br>
TCP를 사용하도록 플러그인을 구성할 수도 있습니다. 중요한 <point>pvestatd</point> 통계 수집 서비스를 차단하지 않으려면 네트워크 문제에 대처하기 위해 타임아웃이 필요합니다.<br></p>
</section>
<section id="influxdb">
<h3>3.6.2. InfluxDB 플러그인 구성<a class="headerlink" href="#influxdb" title="Link to this heading"><span>#</span></a></h3>
<p>Proxmox VE는 UDP를 통해 데이터를 전송하므로 이를 위해 InfluxDB 서버를 구성해야 합니다. 필요한 경우 MTU도 여기에서 구성할 수 있습니다.<br></p>
<p>다음은 InfluxDB 서버에 대한 구성 예시입니다(InfluxDB 서버에서):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">udp</span><span class="p">]]</span>
   <span class="n">enabled</span> <span class="o">=</span> <span class="n">true</span>
   <span class="n">bind</span><span class="o">-</span><span class="n">address</span> <span class="o">=</span> <span class="s2">&quot;0.0.0.0:8089&quot;</span>
   <span class="n">database</span> <span class="o">=</span> <span class="s2">&quot;proxmox&quot;</span>
   <span class="n">batch</span><span class="o">-</span><span class="n">size</span> <span class="o">=</span> <span class="mi">1000</span>
   <span class="n">batch</span><span class="o">-</span><span class="n">timeout</span> <span class="o">=</span> <span class="s2">&quot;1s&quot;</span>
</pre></div>
</div>
<p>이 구성을 사용하면 서버가 포트 8089의 모든 IP 주소에서 수신 대기하고 <point>proxmox</point> 데이터베이스에 데이터를 씁니다.<br></p>
<p>또는 InfluxDB 2.x의 http API를 사용하도록 플러그인을 구성할 수도 있습니다. InfluxDB 1.8.x에는 이 v2 API에 대한 포워드 호환 API 엔드포인트가 포함되어 있습니다.<br></p>
<p>이를 사용하려면 구성에 따라 <point>influxdbproto</point>를 <point>http</point> 또는 <point>https</point>로 설정하세요. 기본적으로 Proxmox VE는 <point>조직</point> proxmox와 <point>버킷</point>/db proxmox를 사용합니다(각각 구성 조직 및 버킷으로 설정할 수 있음).<br></p>
<p>InfluxDB의 v2 API는 인증을 통해서만 사용할 수 있으므로 올바른 버킷에 쓸 수 있는 토큰을 생성하여 설정해야 합니다.<br>
InfluxDB의 v2 호환 API 1.8.x에서는 <point>user:password</point>를 토큰으로 사용할 수 있으며(필요한 경우), <point>조직</point>은 InfluxDB 1.x에서는 의미가 없으므로 생략할 수 있습니다.<br></p>
<p>또한 <point>timeout</point> 설정으로 HTTP 시간 제한(기본값은 1초)을 설정할 수 있으며, <point>max-body-size</point> 설정으로 최대 배치 크기(기본값 25000000 바이트)를 설정할 수 있습니다(이는 동일한 이름의 InfluxDB 설정에 해당).<br></p>
</section>
</section>
<section id="id14">
<h2>3.7. 디스크 상태 모니터링<a class="headerlink" href="#id14" title="Link to this heading"><span>#</span></a></h2>
<p>견고한 이중화 스토리지가 권장되지만 로컬 디스크의 상태를 모니터링하는 것이 매우 유용할 수 있습니다.<br>
Proxmox VE 4.3부터는 <point>smartmontools</point>(https://www.smartmontools.org/ 참조) 패키지가 설치되어 필요합니다. 이 패키지는 로컬 하드 디스크의 S.M.A.R.T. 시스템을 모니터링하고 제어하기 위한 도구 세트입니다.<br></p>
<p>다음 명령을 실행하여 디스크의 상태를 확인할 수 있습니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># smartctl -a /dev/sdX</span>
</pre></div>
</div>
<p>여기서 /dev/sdX는 로컬 디스크 중 하나의 경로입니다.<br>
출력에 다음과 같이 표시되면:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SMART</span> <span class="n">support</span> <span class="ow">is</span><span class="p">:</span> <span class="n">Disabled</span>
</pre></div>
</div>
<p>명령을 사용하여 활성화할 수 있습니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># smartctl -s on /dev/sdX</span>
</pre></div>
</div>
<p>smartctl 사용 방법에 대한 자세한 내용은 <point>man smartctl</point>을 참조하세요.<br>
기본적으로 smartmontools의 서비스인 smartd는 활성화되어 있으며, 30분마다 /dev/sdX 및 /dev/hdX 아래의 디스크에서 오류 및 경고를 검사하고 문제가 감지되면 루트로 이메일을 보냅니다.<br>
smartd를 구성하는 방법에 대한 자세한 내용은 <point>man smartd</point> 및 <point>man smartd.conf</point>를 참조하세요.<br>
하드 디스크를 하드웨어 RAID 컨트롤러와 함께 사용하는 경우, RAID 어레이의 디스크와 어레이 자체를 모니터링하는 도구가 있을 가능성이 높습니다. 이에 대한 자세한 내용은 RAID 컨트롤러의 공급업체에 문의하세요.<br></p>
</section>
<section id="logical-volume-manager-lvm">
<h2>3.8. Logical Volume Manager (LVM)<a class="headerlink" href="#logical-volume-manager-lvm" title="Link to this heading"><span>#</span></a></h2>
<p>대부분의 사용자는 로컬 디스크에 직접 Proxmox VE를 설치합니다. Proxmox VE 설치 CD는 로컬 디스크 관리를 위한 몇 가지 옵션을 제공하며, 현재 기본 설정은 LVM을 사용합니다. 설치 관리자는 이러한 설정을 위해 단일 디스크를 선택하고 해당 디스크를 볼륨 그룹(<point>V</point>olume <point>G</point>roup, VG) <point>pve</point>의 물리적 볼륨으로 사용할 수 있습니다. 다음 출력은 작은 8GB 디스크를 사용한 테스트 설치의 결과입니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># pvs</span>
  <span class="n">PV</span>         <span class="n">VG</span>   <span class="n">Fmt</span>  <span class="n">Attr</span> <span class="n">PSize</span> <span class="n">PFree</span>
  <span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">sda3</span>  <span class="n">pve</span>  <span class="n">lvm2</span> <span class="n">a</span><span class="o">--</span>  <span class="mf">7.87</span><span class="n">g</span> <span class="mf">876.00</span><span class="n">m</span>

<span class="c1"># vgs</span>
  <span class="n">VG</span>   <span class="c1">#PV #LV #SN Attr   VSize VFree</span>
  <span class="n">pve</span>    <span class="mi">1</span>   <span class="mi">3</span>   <span class="mi">0</span> <span class="n">wz</span><span class="o">--</span><span class="n">n</span><span class="o">-</span> <span class="mf">7.87</span><span class="n">g</span> <span class="mf">876.00</span><span class="n">m</span>
</pre></div>
</div>
<p>인스톨러는 이 VG 안에 3개의 논리 볼륨(<point>L</point>ogical <point>V</point>olumes, LV)을 할당합니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># lvs</span>
  <span class="n">LV</span>   <span class="n">VG</span>   <span class="n">Attr</span>       <span class="n">LSize</span>   <span class="n">Pool</span> <span class="n">Origin</span> <span class="n">Data</span><span class="o">%</span>  <span class="n">Meta</span><span class="o">%</span>
  <span class="n">data</span> <span class="n">pve</span>  <span class="n">twi</span><span class="o">-</span><span class="n">a</span><span class="o">-</span><span class="n">tz</span><span class="o">--</span>   <span class="mf">4.38</span><span class="n">g</span>             <span class="mf">0.00</span>   <span class="mf">0.63</span>
  <span class="n">root</span> <span class="n">pve</span>  <span class="o">-</span><span class="n">wi</span><span class="o">-</span><span class="n">ao</span><span class="o">----</span>   <span class="mf">1.75</span><span class="n">g</span>
  <span class="n">swap</span> <span class="n">pve</span>  <span class="o">-</span><span class="n">wi</span><span class="o">-</span><span class="n">ao</span><span class="o">----</span> <span class="mf">896.00</span><span class="n">m</span>
</pre></div>
</div>
<ul class="simple">
<li><p><point>root</point> : <em>ext4</em>로 포맷되며, 운영 체제를 포함</p></li>
<li><p><point>swap</point> : 스왑 파티션</p></li>
<li><p><point>data</point> : 이 볼륨은 LVM-thin을 사용하며 VM 이미지를 저장하는 데 사용됩니다. 이 작업에는 스냅샷 및 클론을 효율적으로 지원하기 때문에 LVM-thin을 사용하는 것이 좋습니다.<br>
Proxmox VE 4.1까지의 버전에서는 설치 관리자가 “data”라는 표준 논리 볼륨을 생성하며, 이 볼륨은 <em>/var/lib/vz</em>에 마운트됩니다.<br>
버전 4.2부터 논리 볼륨 “data”는 블록 기반 게스트 이미지를 저장하는 데 사용되는 LVM-thin 풀이며 <em>/var/lib/vz</em>는 단순히 루트 파일 시스템의 디렉터리입니다.<br><br></p></li>
</ul>
<section id="id15">
<h3>3.8.1. 하드웨어<a class="headerlink" href="#id15" title="Link to this heading"><span>#</span></a></h3>
<p>이러한 설정에는 하드웨어 RAID 컨트롤러(BBU 포함)를 사용할 것을 적극 권장합니다. 이렇게 하면 성능이 향상되고, 중복성이 제공되며, 디스크 교체가 더 쉬워집니다(핫 플러그 가능).<br>
LVM 자체에는 특별한 하드웨어가 필요하지 않으며 메모리 요구 사항도 매우 낮습니다.<br></p>
</section>
<section id="id16">
<h3>3.8.2. 부트 로더<a class="headerlink" href="#id16" title="Link to this heading"><span>#</span></a></h3>
<p>기본적으로 두 개의 부트 로더가 설치됩니다. 첫 번째 파티션에는 표준 GRUB 부트 로더가 들어 있습니다. 두 번째 파티션은 <point>E</point>FI <point>S</point>ystem <point>P</point>artition (ESP)으로, EFI 시스템에서 부팅하고 사용자 공간에서 영구 펌웨어 업데이트를 적용할 수 있습니다.<br></p>
</section>
<section id="id17">
<h3>3.8.3. 볼륨 그룹 생성<a class="headerlink" href="#id17" title="Link to this heading"><span>#</span></a></h3>
<p>“vmdata”라는 볼륨 그룹을 생성하려는 빈 디스크 <point>/dev/sdb</point>가 있다고 가정해 보겠습니다.</p>
<blockquote>
<div><p><img alt="" src="../_images/pin.png" /> 주의 <br>
다음 명령은 <em>/dev/sdb</em>에 있는 모든 기존 데이터를 삭제합니다.</p>
</div></blockquote>
<br>
먼저 파티션을 만듭니다.<br>
<p><point># sgdisk -N 1 /dev/sdb</point><br>
물리 볼륨(PV)을 생성하고 250K 메타데이터사이즈를 생성합니다.<br>
<point># pvcreate –metadatasize 250k -y -ff /dev/sdb1</point><br>
<em>dev/sdb1</em>에 “vmdata”라는 이름의 볼륨 그룹을 생성합니다.<br>
<point># vgcreate vmdata /dev/sdb1</point><br><br></p>
</section>
<section id="var-lib-vz-lv">
<h3>3.8.4. <em>var/lib/vz</em>에 대한 추가 LV 만들기<a class="headerlink" href="#var-lib-vz-lv" title="Link to this heading"><span>#</span></a></h3>
<p>새 thin LV를 생성하면 쉽게 할 수 있습니다.<br>
<point># lvcreate -n <Name> -V &lt;Size[M,G,T]&gt; <VG>/&lt;LVThin_pool&gt;</point><br>
실제 예제입니다:<br>
<point># lvcreate -n vz -V 10G pve/data</point><br>
이제 LV에 파일시스템을 생성해야 합니다.<br>
<point># mkfs.ext4 /dev/pve/vz</point><br>
마지막으로 마운트해야 합니다.<br>
<point># echo ‘/dev/pve/vz /var/lib/vz ext4 defaults 0 2’ &gt;&gt; /etc/fstab</point><br><br></p>
</section>
<section id="thin-pool">
<h3>3.8.5. thin pool 크기 조정하기<a class="headerlink" href="#thin-pool" title="Link to this heading"><span>#</span></a></h3>
<p>다음 명령으로 LV 및 메타데이터 풀의 크기를 조정합니다:<br>
<point># lvresize –size +&lt;size[\M,G,T]&gt; –poolmetadatasize +&lt;size[\M,G]&gt; <VG>/&lt;LVThin_pool&gt;</point><br></p>
<blockquote>
<div><p><img alt="" src="../_images/pin.png" /> 데이터 풀을 확장할 때는 메타데이터 풀도 확장해야 합니다.
<br></p>
</div></blockquote>
</section>
<section id="lvm-thin-pool">
<h3>3.8.6. LVM-thin pool 생성<a class="headerlink" href="#lvm-thin-pool" title="Link to this heading"><span>#</span></a></h3>
<p>볼륨 그룹 위에 씬 풀을 생성해야 합니다. 볼륨 그룹을 만드는 방법은 LVM 섹션을 참조하세요.<br>
<point># lvcreate -L 80G -T -n vmstore vmdata</point><br><br></p>
</section>
</section>
<section id="zfs">
<h2>3.9. ZFS<a class="headerlink" href="#zfs" title="Link to this heading"><span>#</span></a></h2>
<p>ZFS는 Sun Microsystems에서 설계한 결합된 파일 시스템과 논리 볼륨 관리자입니다. Proxmox VE 3.4부터 ZFS 파일 시스템의 네이티브 Linux 커널 포트가 선택적 파일 시스템과 루트 파일 시스템에 대한 추가 선택 사항으로 도입되었습니다. ZFS 모듈을 수동으로 컴파일할 필요가 없으며, 모든 패키지가 포함되어 있습니다.<br>
ZFS를 사용하면 저예산 하드웨어로 최대의 엔터프라이즈 기능을 구현할 수 있을 뿐만 아니라 SSD 캐싱 또는 SSD 전용 설정을 활용하여 고성능 시스템을 구현할 수도 있습니다. ZFS는 적당한 CPU 및 메모리 부하와 쉬운 관리를 결합하여 비용이 많이 드는 하드웨어 RAID 카드를 대체할 수 있습니다.<br><br></p>
<p><point><img alt="" src="../_images/pin.png" /> 일반적인 ZFS의 이점</point><br></p>
<ul class="simple">
<li><p>Proxmox VE GUI 및 CLI를 통한 간편한 구성 및 관리.</p></li>
<li><p>신뢰성</p></li>
<li><p>데이터 손상으로부터 보호</p></li>
<li><p>파일 시스템 수준에서 데이터 압축</p></li>
<li><p>스냅샷</p></li>
<li><p>Copy-on-write 복제</p></li>
<li><p>다양한 RAID 수준: RAID0, RAID1, RAID10, RAIDZ-1, RAIDZ-2, RAIDZ-3, dRAID, dRAID2, dRAID3</p></li>
<li><p>SSD를 캐시로 사용 가능</p></li>
<li><p>자가 치유</p></li>
<li><p>지속적인 무결성 검사</p></li>
<li><p>대용량 스토리지를 위해 설계</p></li>
<li><p>네트워크를 통한 비동기 복제</p></li>
<li><p>오픈 소스</p></li>
<li><p>암호화
<br><br></p></li>
</ul>
<section id="id18">
<h3>3.9.1. 하드웨어<a class="headerlink" href="#id18" title="Link to this heading"><span>#</span></a></h3>
<p>ZFS는 메모리에 크게 의존하므로 시작하려면 최소 8GB가 필요합니다. 실제로는 하드웨어/예산에 맞는 최대한 많은 용량을 사용하세요. 데이터 손상을 방지하려면 고품질 ECC RAM을 사용하는 것이 좋습니다.<br>
전용 캐시 및/또는 로그 디스크를 사용하는 경우에는 엔터프라이즈급 SSD를 사용해야 합니다. 이렇게 하면 전반적인 성능이 크게 향상될 수 있습니다.</p>
<blockquote>
<div><p><img alt="" src="../_images/pin.png" /> 자체 캐시 관리 기능이 있는 하드웨어 RAID 컨트롤러 위에 ZFS를 사용하지 마세요. ZFS는 디스크와 직접 통신해야 합니다. HBA 어댑터 또는 ‘IT’ 모드로 플래시된 LSI 컨트롤러와 같은 것이 더 적합합니다.
VM(중첩 가상화) 내에 Proxmox VE를 설치하여 실험하는 경우 해당 VM의 디스크는 ZFS에서 지원되지 않으므로 가상화 디스크에 <point>virtio</point>를 사용하지 마세요. 대신 IDE 또는 SCSI를 사용하세요(<point>virtio</point> SCSI 컨트롤러 유형과도 작동).<br><br></p>
</div></blockquote>
</section>
<section id="root">
<h3>3.9.2. Root 파일시스템으로 설치<a class="headerlink" href="#root" title="Link to this heading"><span>#</span></a></h3>
<p>Proxmox VE 설치 프로그램을 사용하여 설치하는 경우 root 파일 시스템으로 ZFS를 선택할 수 있습니다. 설치 시 RAID 유형을 선택해야 합니다:</p>
<ul class="simple">
<li><p><point>RAID0</point></p>
<ul>
<li><p>“스트라이핑”이라고도 하며, 볼륨의 용량은 모든 디스크의 용량의 합계입니다.</p></li>
<li><p>RAID0는 이중화하지 않으므로 단일 드라이브가 실패하면 볼륨을 사용할 수 없게 됩니다.</p></li>
</ul>
</li>
<li><p><point>RAID1</point></p>
<ul>
<li><p>“미러링”이라고도 하며, 데이터는 모든 디스크에 동일하게 기록됩니다.</p></li>
<li><p>이 모드는 크기가 같은 디스크가 최소 2개 필요합니다. 결과 용량은 단일 디스크의 용량입니다.</p></li>
</ul>
</li>
<li><p><point>RAID10</point></p>
<ul>
<li><p>RAID0과 RAID1의 조합입니다. 최소 4개의 디스크가 필요합니다.</p></li>
</ul>
</li>
<li><p><point>RAIDZ-1</point></p>
<ul>
<li><p>RAID-5의 변형으로, 단일 패리티입니다. 최소 3개의 디스크가 필요합니다.</p></li>
</ul>
</li>
<li><p><point>RAIDZ-2</point></p>
<ul>
<li><p>RAID-5의 변형, 이중 패리티입니다. 최소 4개의 디스크가 필요합니다.</p></li>
</ul>
</li>
<li><p><point>RAIDZ-3</point></p>
<ul>
<li><p>RAID-5의 변형, 삼중 패리티입니다. 최소 5개의 디스크가 필요합니다.
<br></p></li>
</ul>
</li>
</ul>
<p>설치 프로그램은 자동으로 디스크를 분할하고, <point>rpool</point>이라는 ZFS 풀을 생성하고, ZFS 하위 볼륨 <point>rpool/ROOT/pve-1</point>에 root 파일 시스템을 설치합니다.<br>
<point>rpool/data</point>라는 또 다른 하위 볼륨이 생성되어 VM 이미지를 저장합니다. Proxmox VE 도구와 함께 사용하기 위해 설치 프로그램은 <point>/etc/pve/storage.cfg</point>에 다음 구성 항목을 생성합니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">zfspool</span><span class="p">:</span> <span class="n">local</span><span class="o">-</span><span class="n">zfs</span>
        <span class="n">pool</span> <span class="n">rpool</span><span class="o">/</span><span class="n">data</span>
        <span class="n">sparse</span>
        <span class="n">content</span> <span class="n">images</span><span class="p">,</span><span class="n">rootdir</span>
</pre></div>
</div>
<p>설치 후 <point>zpool</point> 명령을 사용하여 ZFS 풀 상태를 볼 수 있습니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># zpool status</span>
  <span class="n">pool</span><span class="p">:</span> <span class="n">rpool</span>
 <span class="n">state</span><span class="p">:</span> <span class="n">ONLINE</span>
  <span class="n">scan</span><span class="p">:</span> <span class="n">none</span> <span class="n">requested</span>
<span class="n">config</span><span class="p">:</span>

        <span class="n">NAME</span>        <span class="n">STATE</span>     <span class="n">READ</span> <span class="n">WRITE</span> <span class="n">CKSUM</span>
        <span class="n">rpool</span>       <span class="n">ONLINE</span>       <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
          <span class="n">mirror</span><span class="o">-</span><span class="mi">0</span>  <span class="n">ONLINE</span>       <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
            <span class="n">sda2</span>    <span class="n">ONLINE</span>       <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
            <span class="n">sdb2</span>    <span class="n">ONLINE</span>       <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
          <span class="n">mirror</span><span class="o">-</span><span class="mi">1</span>  <span class="n">ONLINE</span>       <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
            <span class="n">sdc</span>     <span class="n">ONLINE</span>       <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
            <span class="n">sdd</span>     <span class="n">ONLINE</span>       <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>

<span class="n">errors</span><span class="p">:</span> <span class="n">No</span> <span class="n">known</span> <span class="n">data</span> <span class="n">errors</span>

</pre></div>
</div>
<p><point>zfs</point> 명령은 ZFS 파일 시스템을 구성하고 관리하는 데 사용됩니다. 다음 명령은 설치 후 모든 파일 시스템을 나열합니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># zfs list</span>
<span class="n">NAME</span>               <span class="n">USED</span>  <span class="n">AVAIL</span>  <span class="n">REFER</span>  <span class="n">MOUNTPOINT</span>
<span class="n">rpool</span>             <span class="mf">4.94</span><span class="n">G</span>  <span class="mf">7.68</span><span class="n">T</span>    <span class="mi">96</span><span class="n">K</span>  <span class="o">/</span><span class="n">rpool</span>
<span class="n">rpool</span><span class="o">/</span><span class="n">ROOT</span>         <span class="mi">702</span><span class="n">M</span>  <span class="mf">7.68</span><span class="n">T</span>    <span class="mi">96</span><span class="n">K</span>  <span class="o">/</span><span class="n">rpool</span><span class="o">/</span><span class="n">ROOT</span>
<span class="n">rpool</span><span class="o">/</span><span class="n">ROOT</span><span class="o">/</span><span class="n">pve</span><span class="o">-</span><span class="mi">1</span>   <span class="mi">702</span><span class="n">M</span>  <span class="mf">7.68</span><span class="n">T</span>   <span class="mi">702</span><span class="n">M</span>  <span class="o">/</span>
<span class="n">rpool</span><span class="o">/</span><span class="n">data</span>          <span class="mi">96</span><span class="n">K</span>  <span class="mf">7.68</span><span class="n">T</span>    <span class="mi">96</span><span class="n">K</span>  <span class="o">/</span><span class="n">rpool</span><span class="o">/</span><span class="n">data</span>
<span class="n">rpool</span><span class="o">/</span><span class="n">swap</span>        <span class="mf">4.25</span><span class="n">G</span>  <span class="mf">7.69</span><span class="n">T</span>    <span class="mi">64</span><span class="n">K</span>  <span class="o">-</span>
</pre></div>
</div>
</section>
<section id="zfs-raid">
<h3>3.9.3. ZFS RAID 레벨 고려 사항<a class="headerlink" href="#zfs-raid" title="Link to this heading"><span>#</span></a></h3>
<p>ZFS 풀의 레이아웃을 선택할 때 고려해야 할 몇 가지 요소가 있습니다. ZFS 풀의 기본 구성 요소는 가상 장치 또는 <point>vdev</point>입니다. 풀의 모든 vdev는 동등하게 사용되고 데이터는 이들 사이에 스트라이프됩니다(RAID0). vdev에 대한 자세한 내용은 <point>zpoolconcepts(7)</point> 매뉴얼 페이지를 확인하세요.<br><br></p>
<p><point><img alt="" src="../_images/pin.png" /> 성능</point><br>
각 <point>vdev</point> 유형마다 성능 동작이 다릅니다. 관심 있는 두 가지 매개변수는 IOPS(초당 입/출력 작업 수)와 데이터를 쓰거나 읽을 수 있는 대역폭입니다.<br>
<point>미러</point> vdev(RAID1)는 데이터를 쓸 때 두 매개변수와 관련하여 대략 단일 디스크처럼 작동합니다. 데이터를 읽을 때는 미러의 디스크 수에 따라 성능이 선형적으로 확장됩니다.<br>
일반적인 상황은 4개의 디스크를 사용하는 것입니다. 2개의 미러 디바이스(RAID10)로 설정하면 풀은 IOPS 및 대역폭과 관련하여 2개의 단일 디스크와 같은 쓰기 특성을 갖습니다. 읽기 작업의 경우 4개의 단일 디스크와 유사합니다.<br>
모든 중복성 수준의 <point>RAIDZ</point>는 대역폭이 많은 IOPS와 관련하여 대략 단일 디스크처럼 작동합니다. 대역폭의 양은 RAIDZ vdev의 크기와 중복성 수준에 따라 달라집니다.<br>
<point>dRAID</point> 풀은 동등한 <point>RAIDZ</point> 풀의 성능과 일치해야 합니다.<br>
실행 중인 VM의 경우 대부분의 상황에서 IOPS가 더 중요한 지표입니다.<br><br></p>
<p><point><img alt="" src="../_images/pin.png" /> 크기, 공간 사용량 및 이중화</point><br>
<point>미러</point> 가상 디스크로 구성된 풀의 성능 특성이 가장 우수하지만, 사용 가능한 공간은 사용 가능한 디스크의 50%입니다. 예를 들어 3방향 미러와 같이 미러 vdev가 2개 이상의 디스크로 구성된 경우에는 더 적습니다. 풀이 계속 작동하려면 미러당 하나 이상의 정상 디스크가 필요합니다.<br></p>
<p>N개의 디스크로 구성된 <point>RAIDZ</point> 유형 vdev의 사용 가능한 공간은 대략 N-P이며, 여기서 P는 RAIDZ 레벨입니다. RAIDZ 레벨은 데이터 손실 없이 장애가 발생할 수 있는 임의의 디스크 수를 나타냅니다. 특별한 경우는 RAIDZ2가 있는 4개의 디스크 풀입니다. 이 상황에서는 일반적으로 사용 가능한 공간이 동일하므로 더 나은 성능을 위해 2개의 미러 디바이스를 사용하는 것이 좋습니다.<br></p>
<p>RAIDZ 레벨을 사용할 때 또 다른 중요한 요소는 VM 디스크에 사용되는 ZVOL 데이터 세트의 작동 방식입니다. 각 데이터 블록에 대해 풀의 패리티 데이터는 최소한 풀의 <point>ashift</point> 값으로 정의된 최소 블록 크기만큼의 크기가 필요합니다. 애시프트가 12인 경우 풀의 블록 크기는 4k입니다. ZVOL의 기본 블록 크기는 8k입니다. 따라서 RAIDZ2에서 8k 블록을 기록할 때마다 4k 패리티 블록 2개(8k + 4k + 4k = 16k)가 추가로 기록됩니다. 물론 이것은 단순화된 접근 방식이며 이 예에서는 메타데이터, 압축 등을 고려하지 않았기 때문에 실제 상황은 약간 다를 수 있습니다.<br></p>
<p>이 동작은 ZVOL의 다음 속성을 확인할 때 관찰할 수 있습니다:<br>
<br>
<br></p>
</section>
</section>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="02-install.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">2. Proxmox VE 기본설치</p>
      </div>
    </a>
    <a class="right-next"
       href="04-gui.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">4. GUI</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">3.1. 패키지 레포지토리</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#proxmox-ve">3.1.1. Proxmox VE의 레포지토리</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#proxmox-ve-enterprise-repository">3.1.2. Proxmox VE Enterprise Repository</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#proxmox-ve-no-subscription-repository">3.1.3. Proxmox VE No-Subscription Repository</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#proxmox-ve-test-repository">3.1.4. Proxmox VE Test Repository</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ceph-squid-enterprise-repository">3.1.5. Ceph Squid Enterprise Repository</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ceph-squid-no-subscription-repository">3.1.6. Ceph Squid No-Subscription Repository</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ceph-squid-test-repository">3.1.7. Ceph Squid Test Repository</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ceph-reef-enterprise-repository">3.1.8. Ceph Reef Enterprise Repository</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ceph-reef-no-subscription-repository">3.1.9. Ceph Reef No-Subscription Repository</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ceph-reef-test-repository">3.1.10. Ceph Reef Test Repository</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">3.2. 시스템 소프트웨어 업데이트</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">3.3. 펌웨어 업데이트</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">3.3.1. 영구 펌웨어</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">3.4. 네트워크 구성</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">3.4.1. 네트워크 변경 사항 적용</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">3.4.2. 명명 규칙</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">3.4.3. 네트워크 구성 선택하기</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">3.4.4. 브릿지를 사용한 기본 구성</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">3.4.5 라우팅 구성</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#linux-bond">3.4.7 Linux Bond</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#vlan-802-1q">3.4.8. VLAN 802.1Q</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ipv6">3.4.9. 노드에서 IPv6 비활성화하기</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mac">3.4.10. 브릿지에서 MAC 학습 기능 비활성화하기</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">3.5. 시간 동기화</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ntp">3.5.1. 사용자 지정 NTP 서버 사용</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id13">3.6. 외부 메트릭 서버</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#graphite">3.6.1. Graphite 서버 구성</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#influxdb">3.6.2. InfluxDB 플러그인 구성</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id14">3.7. 디스크 상태 모니터링</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#logical-volume-manager-lvm">3.8. Logical Volume Manager (LVM)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">3.8.1. 하드웨어</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id16">3.8.2. 부트 로더</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id17">3.8.3. 볼륨 그룹 생성</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#var-lib-vz-lv">3.8.4. <em>var/lib/vz</em>에 대한 추가 LV 만들기</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#thin-pool">3.8.5. thin pool 크기 조정하기</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lvm-thin-pool">3.8.6. LVM-thin pool 생성</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#zfs">3.9. ZFS</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id18">3.9.1. 하드웨어</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#root">3.9.2. Root 파일시스템으로 설치</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#zfs-raid">3.9.3. ZFS RAID 레벨 고려 사항</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By phum
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2025, phum.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>